{
  "App.vue": "<template>\n    <div id=\"app-wrapper\">\n        <header class=\"app-header\">\n            <nav>\n                <router-link :to=\"{ name: 'home' }\">Home</router-link>\n            </nav>\n            <div class=\"auth-section\">\n                <BaseLoadingIndicator v-if=\"isAuthLoading\" message=\"Auth...\" />\n                <BaseErrorMessage :message=\"authError\" />\n                <span v-if=\"isLoggedIn && user\">Welcome, {{ user.email }}!</span>\n                <button v-if=\"isLoggedIn\" @click=\"handleSignOut\">Sign Out</button>\n            </div>\n        </header>\n\n        <main class=\"app-main\">\n            <router-view v-slot=\"{ Component, route }\">\n                <component :is=\"Component\" :key=\"route.path\" />\n            </router-view>\n        </main>\n\n        <footer class=\"app-footer\">\n            <p>© {{ new Date().getFullYear() }} Bible App</p>\n        </footer>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { useSupabaseAuth } from '@/composables/useSupabaseAuth';\nimport BaseLoadingIndicator from '@/components/BaseLoadingIndicator.vue';\nimport BaseErrorMessage from '@/components/BaseErrorMessage.vue';\nimport { useRouter } from 'vue-router';\n\nconst router = useRouter();\nconst {\n    user,\n    isLoggedIn,\n    isLoading: isAuthLoading, // Renamed to avoid conflict if other loading states exist\n    error: authError,\n    signOut\n} = useSupabaseAuth();\n\nconst handleSignOut = async () => {\n    const { success } = await signOut();\n    if (success) {\n        // Optionally navigate the user after sign out\n        router.push({ name: 'home' });\n        console.log('User signed out successfully.');\n    } else {\n        // Error is handled and displayed by the auth store/composable\n        console.error('Sign out failed.');\n    }\n};\n\n// Global error handling example (optional)\n// import { onErrorCaptured } from 'vue';\n// onErrorCaptured((err, instance, info) => {\n//   console.error(\"Unhandled error captured in App.vue:\", err, info);\n//   // Send to logging service (Sentry, etc.)\n//   // Display a generic error message to the user\n//   // globalError.value = 'An unexpected error occurred.';\n//   return false; // Prevent propagation if handled\n// });\n\n</script>\n\n<style scoped>\n#app-wrapper {\n    display: flex;\n    flex-direction: column;\n    min-height: 100vh;\n    background-color: var(--bg-primary);\n}\n\n.app-header {\n    padding: var(--spacing-sm) var(--spacing-lg);\n    background-color: var(--bg-secondary);\n    border-bottom: 1px solid var(--border-divider);\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: var(--spacing-md);\n}\n\n.app-header nav {\n    display: flex;\n    gap: var(--spacing-md);\n}\n\n.app-header nav a {\n    color: var(--text-link);\n    text-decoration: none;\n    font-weight: 500;\n}\n\n.app-header nav a:hover,\n.app-header nav a.router-link-exact-active {\n    color: var(--text-link-hover);\n    text-decoration: underline;\n}\n\n.auth-section {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n    font-size: 0.9rem;\n    color: var(--text-secondary);\n}\n\n.auth-section button {\n    padding: var(--spacing-xs) var(--spacing-sm);\n    font-size: 0.85rem;\n    border: 1px solid var(--border-primary);\n    background-color: var(--bg-primary);\n    color: var(--text-primary);\n    border-radius: var(--radius-sm);\n    cursor: pointer;\n}\n\n.auth-section button:hover {\n    background-color: var(--bg-tertiary);\n}\n\n.auth-section .loading-indicator,\n.auth-section .error-message-box {\n    padding: var(--spacing-xs);\n    margin: 0;\n    font-size: 0.8rem;\n    border: none;\n    background: none;\n}\n\n.auth-section .loading-indicator .spinner {\n    width: 16px;\n    height: 16px;\n    border-width: 2px;\n}\n\n\n.app-main {\n    flex-grow: 1;\n}\n\n.app-footer {\n    padding: var(--spacing-md) var(--spacing-lg);\n    text-align: center;\n    font-size: 0.85rem;\n    color: var(--text-secondary);\n    border-top: 1px solid var(--border-divider);\n    background-color: var(--bg-secondary);\n    margin-top: auto;\n}\n\n.app-footer p {\n    margin: 0;\n}\n</style>",
  "api": {},
  "assets": {
    "main.css": "/* Keep only the light theme variables */\n:root {\n  --bg-primary: #ffffff;\n  --bg-secondary: #f8fafd;\n  --bg-tertiary: #f1f5f9; /* Slightly adjusted tertiary */\n  --text-primary: #2c3e50;\n  --text-secondary: #64748b; /* Adjusted secondary text */\n  --text-heading: #1e293b; /* Darker heading */\n  --text-link: #3b82f6; /* Brighter blue link */\n  --text-link-hover: #2563eb; /* Darker blue hover */\n  --border-primary: #e2e8f0; /* Lighter border */\n  --border-secondary: #cbd5e1;\n  --border-hover: #94a3b8; /* Greyish hover border */\n  --border-divider: #f1f5f9; /* Very light divider */\n  --error-bg: #fee2e2; /* Lighter error bg */\n  --error-text: #b91c1c; /* Darker error text */\n  --error-border: #fecaca; /* Lighter error border */\n  --shadow-color-light: rgba(0, 0, 0, 0.05);\n  --shadow-color-medium: rgba(0, 0, 0, 0.1);\n\n  --spacing-xs: 4px; /* Adjusted spacing scale slightly */\n  --spacing-sm: 8px;\n  --spacing-md: 16px;\n  --spacing-lg: 24px;\n  --spacing-xl: 32px;\n  --radius-sm: 4px;\n  --radius-md: 6px;\n  --radius-lg: 8px;\n\n  --transition-fast: 0.15s ease-in-out;\n  --transition-std: 0.2s ease-in-out;\n}\n\n/* --- Global Resets & Base Styles --- */\n\n*,\n*::before,\n*::after {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n\nhtml {\n  font-size: 16px;\n  scroll-behavior: smooth; /* Smooth scrolling for anchors */\n}\n\nbody {\n  font-family:\n    Inter,\n    -apple-system,\n    BlinkMacSystemFont,\n    'Segoe UI',\n    Roboto,\n    Helvetica,\n    Arial,\n    sans-serif,\n    'Apple Color Emoji',\n    'Segoe UI Emoji'; /* Modern font stack */\n  background-color: var(--bg-primary);\n  color: var(--text-primary);\n  line-height: 1.6;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  transition:\n    background-color var(--transition-std),\n    color var(--transition-std);\n}\n\na {\n  color: var(--text-link);\n  text-decoration: none;\n  transition: color var(--transition-fast);\n}\n\na:hover {\n  color: var(--text-link-hover);\n  text-decoration: underline;\n}\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  text-align: center;\n  color: var(--text-heading);\n  margin-bottom: var(--spacing-md);\n  line-height: 1.3;\n  font-weight: 600;\n}\n\nh1 {\n  font-size: 2rem;\n}\nh2 {\n  font-size: 1.5rem;\n}\nh3 {\n  font-size: 1.25rem;\n}\n/* Add h4, h5, h6 if needed */\n\np {\n  margin-bottom: var(--spacing-md);\n}\n\n/* --- Layout & Utility Classes --- */\n\n.container {\n  max-width: 960px; /* Slightly wider container */\n  margin-left: auto;\n  margin-right: auto;\n  padding-left: var(--spacing-lg);\n  padding-right: var(--spacing-lg);\n  width: 100%;\n}\n\n/* Reusable loading/error text styles (used by base components) */\n.loading-indicator p, /* Target the p inside the component */\n.error-message-box p {\n  /* Target the p inside the component */\n  margin: 0; /* Remove default paragraph margin */\n}\n\n/* Card Style */\n.card {\n  border: 1px solid var(--border-primary);\n  padding: var(--spacing-lg);\n  border-radius: var(--radius-lg);\n  background-color: var(--bg-primary); /* Use primary bg for cards */\n  box-shadow:\n    0 1px 3px var(--shadow-color-light),\n    0 1px 2px var(--shadow-color-light); /* Subtle shadow */\n  transition:\n    box-shadow var(--transition-std),\n    transform var(--transition-std);\n}\n\n.card:hover {\n  box-shadow:\n    0 4px 6px var(--shadow-color-light),\n    0 1px 3px var(--shadow-color-medium); /* Slightly stronger hover shadow */\n  transform: translateY(-2px);\n}\n\n/* List Item Link Style */\n.list-item-link {\n  display: block;\n  text-decoration: none;\n  color: var(--text-primary);\n  background-color: var(--bg-secondary); /* Use secondary for list items */\n  border: 1px solid var(--border-primary);\n  padding: var(--spacing-sm) var(--spacing-md);\n  margin-bottom: var(--spacing-sm);\n  border-radius: var(--radius-md);\n  transition:\n    background-color var(--transition-std),\n    border-color var(--transition-std),\n    transform var(--transition-fast),\n    box-shadow var(--transition-std);\n  box-shadow: 0 1px 2px var(--shadow-color-light);\n}\n\n.list-item-link:hover,\n.list-item-link:focus {\n  background-color: var(--bg-tertiary); /* Use tertiary for hover */\n  border-color: var(--border-secondary);\n  transform: translateY(-1px);\n  box-shadow: 0 2px 4px var(--shadow-color-light);\n  outline: none;\n  color: var(--text-link); /* Highlight text on hover */\n}\n\n.list-item-link:last-child {\n  margin-bottom: 0;\n}\n\n/* Divider */\n.divider {\n  border: 0;\n  height: 1px;\n  background-color: var(--border-divider);\n  margin: var(--spacing-lg) 0;\n}\n\n/* View Header Style */\n.view-header {\n  margin-bottom: var(--spacing-lg);\n  padding-bottom: var(--spacing-md); /* Adjusted padding */\n  border-bottom: 1px solid var(--border-divider);\n  text-align: center; /* Center header content by default */\n}\n.view-header h1,\n.view-header h2 {\n  margin-bottom: 0; /* Remove bottom margin within header */\n}\n\n/* Add other global styles or utility classes as needed */\n"
  },
  "components": {
    "BaseErrorMessage.vue": "<template>\n    <div v-if=\"message\" class=\"error-message-box\" role=\"alert\">\n        <p><strong>Error:</strong> {{ message }}</p>\n        <!-- Optionally add an icon or close button -->\n    </div>\n</template>\n\n<script setup lang=\"ts\">\ninterface Props {\n    message: string | null | undefined;\n}\n\ndefineProps<Props>();\n</script>\n\n<style scoped>\n.error-message-box {\n    color: var(--error-text);\n    background-color: var(--error-bg);\n    border: 1px solid var(--error-border);\n    padding: var(--spacing-md);\n    border-radius: var(--radius-sm);\n    margin: var(--spacing-lg) 0;\n    text-align: center;\n}\n\n.error-message-box p {\n    margin: 0;\n}\n</style>",
    "BaseLoadingIndicator.vue": "<template>\n    <div class=\"loading-indicator\" role=\"status\" aria-live=\"polite\">\n        <p>{{ message }}</p>\n        <!-- Add a spinner or animation here if desired -->\n        <div class=\"spinner\"></div>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\ninterface Props {\n    message?: string;\n}\n\nwithDefaults(defineProps<Props>(), {\n    message: 'Loading...',\n});\n</script>\n\n<style scoped>\n.loading-indicator {\n    text-align: center;\n    color: var(--text-secondary);\n    padding: var(--spacing-xl) var(--spacing-md);\n    font-style: italic;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    gap: var(--spacing-sm);\n}\n\n/* Basic Spinner Example */\n.spinner {\n    border: 4px solid var(--bg-secondary);\n    border-top: 4px solid var(--text-link);\n    border-radius: 50%;\n    width: 30px;\n    height: 30px;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% {\n        transform: rotate(0deg);\n    }\n\n    100% {\n        transform: rotate(360deg);\n    }\n}\n</style>",
    "TestamentGenreList.vue": "<template>\n  <div class=\"testament-genre-list\">\n    <BaseLoadingIndicator v-if=\"isLoading\" message=\"Loading genres...\" />\n    <BaseErrorMessage :message=\"error\" />\n\n    <div v-if=\"!isLoading && !error && genres.length > 0\">\n      <div v-if=\"!isLoading && !error && genres.length > 0\">\n        <router-link v-for=\"genre in genres\" :key=\"genre.genre_id\" :to=\"{\n          name: 'genre-detail',\n          params: { testamentSlug: props.testamentSlug, genreSlug: genre.slug },\n        }\" class=\"genre-link list-item-link\" v-prefetch=\"{\n          queryKey: ['genre_detail', genre.slug],\n          queryFn: () => fetchGenreBySlug(genre.slug),\n          staleTime: 60 * 1000\n        }\">\n          {{ genre.name }}\n        </router-link>\n      </div>\n\n      <p v-if=\"!isLoading && !error && genres.length === 0\" class=\"no-results\">\n        No specific genres found listed under this testament.\n      </p>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { toRef } from 'vue';\nimport { useTestamentGenres } from '@/composables/useBibleData';\nimport { fetchGenreBySlug } from '@/services/apiService';\nimport BaseLoadingIndicator from '@/components/BaseLoadingIndicator.vue';\nimport BaseErrorMessage from '@/components/BaseErrorMessage.vue';\n\ninterface Props {\n  testamentId: number | null; // Allow null initially\n  testamentSlug: string; // Needed for linking\n}\n\nconst props = defineProps<Props>();\nconst testamentIdRef = toRef(props, 'testamentId');\nconst { data: genres, isLoading, error } = useTestamentGenres(testamentIdRef);\n\n</script>\n\n<style scoped>\n.testament-genre-list {\n  padding-top: var(--spacing-lg);\n}\n\n.no-results {\n  text-align: center;\n  color: var(--text-secondary);\n  margin-top: var(--spacing-lg);\n  font-style: italic;\n}\n</style>"
  },
  "composables": {
    "useBibleData.ts": "// src/composables/useBibleData.ts\n/**\n * @file Composable functions for fetching and managing Bible-related data state using Vue Query.\n * Adapted for the refactored schema.\n */\nimport { type Ref, computed } from 'vue'\nimport { useQuery } from '@tanstack/vue-query'\nimport * as apiService from '@/services/apiService'\nimport type {\n  TestamentTranslation,\n  GenreTranslation,\n  BookSummary,\n  Chapter, // Keep simple type if needed, or remove if only numbers used\n  Version,\n  Verse, // Use updated Verse type\n  BaseVerse, // Use updated BaseVerse type\n} from '@/types'\n\n// Re-export types for convenience if needed elsewhere\nexport type { TestamentTranslation, GenreTranslation, BookSummary, Version, Verse, BaseVerse }\n\n// --- Testament Queries (Largely Unchanged Semantically) ---\n\nexport function useTestaments() {\n  return useQuery({\n    queryKey: ['testaments'],\n    queryFn: apiService.fetchTestaments,\n    // staleTime: 5 * 60 * 1000, // Example\n  })\n}\n\nexport function useTestamentDetails(testamentSlugRef: Ref<string | undefined>) {\n  return useQuery({\n    queryKey: ['testament_detail', testamentSlugRef],\n    queryFn: () => {\n      const slug = testamentSlugRef.value\n      if (!slug) {\n        throw new Error('Testament slug is required but missing.')\n      }\n      return apiService.fetchTestamentBySlug(slug)\n    },\n    enabled: computed(() => !!testamentSlugRef.value),\n  })\n}\n\n// --- Genre Queries (Largely Unchanged Semantically) ---\n\nexport function useTestamentGenres(testamentIdRef: Ref<number | null>) {\n  return useQuery({\n    queryKey: ['testament_genres', testamentIdRef],\n    queryFn: () => {\n      const id = testamentIdRef.value\n      if (id === null) {\n        throw new Error('Testament ID is required but missing.')\n      }\n      return apiService.fetchGenresForTestament(id)\n    },\n    enabled: computed(() => typeof testamentIdRef.value === 'number'),\n  })\n}\n\nexport function useGenreDetails(genreSlugRef: Ref<string | undefined>) {\n  return useQuery({\n    queryKey: ['genre_detail', genreSlugRef],\n    queryFn: () => {\n      const slug = genreSlugRef.value\n      if (!slug) {\n        throw new Error('Genre slug is required but missing.')\n      }\n      return apiService.fetchGenreBySlug(slug)\n    },\n    enabled: computed(() => !!genreSlugRef.value),\n  })\n}\n\n// --- Book Queries (Updated Service Calls) ---\n\nexport function useBooksByGenre(genreIdRef: Ref<number | null>) {\n  return useQuery({\n    queryKey: ['books_by_genre', genreIdRef],\n    queryFn: () => {\n      const id = genreIdRef.value\n      if (id === null) {\n        throw new Error('Genre ID is required but missing.')\n      }\n      return apiService.fetchBooksByGenre(id) // Uses updated service call\n    },\n    enabled: computed(() => typeof genreIdRef.value === 'number'),\n  })\n}\n\nexport function useBookDetails(bookSlugRef: Ref<string | undefined>) {\n  return useQuery({\n    queryKey: ['book_detail', bookSlugRef],\n    queryFn: () => {\n      const slug = bookSlugRef.value\n      if (!slug) {\n        throw new Error('Book slug is required but missing.')\n      }\n      // Returns { book_id, title, cleaned_book_label }\n      return apiService.fetchBookBySlug(slug) // Uses updated service call\n    },\n    enabled: computed(() => !!bookSlugRef.value),\n  })\n}\n\n// --- Version Query (Updated Service Call) ---\n\nexport function useBibleVersions() {\n  return useQuery({\n    queryKey: ['bible_versions'],\n    queryFn: apiService.fetchAvailableVersions, // Uses updated service call\n  })\n}\n\n// --- Chapter Query (NEW LOGIC) ---\n\n/**\n * Fetches chapter numbers for a given book ID, book label, and version code.\n * @param bookIdRef - Ref containing the book ID (bible_books.id).\n * @param bookLabelRef - Ref containing the cleaned book label (for ltree path).\n * @param versionCodeRef - Ref containing the version code (for ltree path).\n * @returns Vue Query result object for chapter numbers (number[]).\n */\nexport function useChapterNumbers(\n  bookIdRef: Ref<number | null>,\n  bookLabelRef: Ref<string | null>,\n  versionCodeRef: Ref<string | null>,\n) {\n  return useQuery({\n    queryKey: ['chapter_numbers', bookIdRef, bookLabelRef, versionCodeRef],\n    queryFn: () => {\n      const bookId = bookIdRef.value\n      const bookLabel = bookLabelRef.value\n      const versionCode = versionCodeRef.value\n\n      if (bookId === null || bookLabel === null || versionCode === null) {\n        throw new Error('Book ID, Book Label, and Version Code are required for fetching chapters.')\n      }\n      // Calls the NEW service function\n      return apiService.fetchChaptersForBook(bookId, bookLabel, versionCode)\n    },\n    enabled: computed(\n      () =>\n        typeof bookIdRef.value === 'number' &&\n        bookLabelRef.value !== null &&\n        versionCodeRef.value !== null,\n    ),\n    // Consider staleTime for chapter lists\n    staleTime: 10 * 60 * 1000, // Chapters rarely change\n  })\n}\n\n// --- Verse & Link Queries (NEW LOGIC) ---\n\n/**\n * Fetches base verses (text, number, ID, path) for a given chapter using ltree path components.\n * Does NOT fetch linked sources initially.\n *\n * @param bookLabelRef - Ref containing the cleaned book label (e.g., 'gen').\n * @param chapterNumberRef - Ref containing the chapter number.\n * @param versionCodeRef - Ref containing the version code (e.g., 'vul').\n * @returns Vue Query result object for base verses.\n * @see useCatechismLinksForVerses for fetching linked CCC paragraph numbers.\n */\nexport function useVerseText(\n  bookLabelRef: Ref<string | null>,\n  chapterNumberRef: Ref<number | null>,\n  versionCodeRef: Ref<string | null>,\n) {\n  return useQuery({\n    queryKey: ['verseText', bookLabelRef, chapterNumberRef, versionCodeRef],\n    queryFn: async (): Promise<BaseVerse[]> => {\n      const bookLabel = bookLabelRef.value\n      const chapterNumber = chapterNumberRef.value\n      const versionCode = versionCodeRef.value\n\n      if (bookLabel === null || chapterNumber === null || versionCode === null) {\n        throw new Error(\n          'Book Label, Chapter Number, and Version Code are required for fetching verses.',\n        )\n      }\n\n      console.debug(\n        `[useVerseText queryFn] Fetching verses for ${bookLabel} Ch ${chapterNumber}, Version ${versionCode}`,\n      )\n      // Call the NEW service function that uses ltree path\n      const versesData = await apiService.fetchVersesForChapter(\n        bookLabel,\n        chapterNumber,\n        versionCode,\n      )\n      console.debug(`[useVerseText queryFn] Fetched ${versesData.length} base verses.`)\n      // Ensure the returned data matches the updated BaseVerse type\n      return versesData\n    },\n    enabled: computed(\n      () =>\n        bookLabelRef.value !== null &&\n        typeof chapterNumberRef.value === 'number' &&\n        versionCodeRef.value !== null,\n    ),\n    staleTime: 5 * 60 * 1000,\n  })\n}\n\n/**\n * Fetches Catechism paragraph numbers (ccc_num/sort_order) linked to a given set of verse IDs (core_unit.id).\n * Uses the RPC function 'get_ccc_nums_for_verse_ids'.\n *\n * @param verseIdsRef - A Ref containing an array of verse IDs (core_unit.id), or undefined/null.\n * @returns Vue Query result object containing a Map<verse_id, ccc_num[]>.\n */\nexport function useCatechismLinksForVerses(verseIdsRef: Ref<number[] | undefined | null>) {\n  return useQuery({\n    // Query key depends on the sorted list of IDs to ensure stability\n    queryKey: [\n      'cccLinks',\n      computed(() => verseIdsRef.value?.sort((a, b) => a - b).join(',') ?? ''),\n    ],\n    queryFn: async (): Promise<Map<number, number[]>> => {\n      const verseIds = verseIdsRef.value\n\n      if (!verseIds || verseIds.length === 0) {\n        console.debug(\n          '[useCatechismLinksForVerses queryFn] No verse IDs provided, returning empty map.',\n        )\n        return new Map()\n      }\n\n      console.debug(\n        `[useCatechismLinksForVerses queryFn] Fetching CCC links via RPC for ${verseIds.length} verse IDs.`,\n      )\n      // Call the UPDATED service function using the new RPC\n      const indexMap = await apiService.fetchCatechismLinksViaRpc(verseIds)\n      console.debug(\n        `[useCatechismLinksForVerses queryFn] Fetched CCC links via RPC. Found links for ${indexMap.size} verses.`,\n      )\n      return indexMap\n    },\n    enabled: computed(() => !!verseIdsRef.value && verseIdsRef.value.length > 0),\n    staleTime: 10 * 60 * 1000,\n    gcTime: 30 * 60 * 1000,\n  })\n}\n",
    "useDelayedState.ts": "// src/composables/useDelayedState.ts\nimport { ref, watch, type Ref, onUnmounted } from 'vue'\n\n/**\n * Creates a ref that reflects the value of a source ref but only\n * becomes true after a specified delay. Resets immediately if the source becomes false.\n * @param sourceRef The source boolean ref (e.g., isLoading).\n * @param delayMs The delay in milliseconds before the returned ref becomes true.\n * @returns A ref that is true only if the sourceRef has been true for delayMs.\n */\nexport function useDelayedTrueState(sourceRef: Ref<boolean>, delayMs: number = 600): Ref<boolean> {\n  const delayedState = ref(false)\n  let timerId: ReturnType<typeof setTimeout> | null = null\n\n  watch(\n    sourceRef,\n    (newValue) => {\n      if (newValue) {\n        // Source became true, start timer\n        if (timerId === null) {\n          // Prevent multiple timers\n          timerId = setTimeout(() => {\n            // Only set to true if source is STILL true after delay\n            if (sourceRef.value) {\n              delayedState.value = true\n            }\n            timerId = null // Timer finished\n          }, delayMs)\n        }\n      } else {\n        // Source became false, clear timer and reset state immediately\n        if (timerId !== null) {\n          clearTimeout(timerId)\n          timerId = null\n        }\n        delayedState.value = false\n      }\n    },\n    { immediate: true },\n  ) // Check initial state\n\n  // Cleanup timer on component unmount\n  onUnmounted(() => {\n    if (timerId !== null) {\n      clearTimeout(timerId)\n    }\n  })\n\n  return delayedState\n}\n",
    "useSupabaseAuth.ts": "/**\n * @file Composable to easily access the auth store state and actions.\n * Provides a cleaner interface for components compared to directly importing the store.\n */\nimport { computed } from 'vue'\nimport { useAuthStore } from '@/stores/auth.store'\nimport type {\n  SignInWithPasswordCredentials,\n  SignUpWithPasswordCredentials,\n} from '@supabase/supabase-js'\n\nexport function useSupabaseAuth() {\n  const authStore = useAuthStore()\n\n  // Expose state and getters as computed refs for reactivity\n  const user = computed(() => authStore.user)\n  const session = computed(() => authStore.session)\n  const isLoading = computed(() => authStore.isLoading)\n  const error = computed(() => authStore.error)\n  const isLoggedIn = computed(() => authStore.isLoggedIn)\n  const userId = computed(() => authStore.userId)\n\n  // Expose actions directly\n  const { init, signInWithEmail, signUpWithEmail, signOut } = authStore\n\n  return {\n    // State & Getters (as computed refs)\n    user,\n    session,\n    isLoading,\n    error,\n    isLoggedIn,\n    userId,\n\n    // Actions (as functions)\n    init,\n    signInWithEmail,\n    signUpWithEmail,\n    signOut,\n  }\n}\n"
  },
  "constants": {
    "index.ts": "/**\n * @file Application-wide constants.\n */\n\n/**\n * Default language code used throughout the application.\n * Currently set to French.\n */\nexport const DEFAULT_LANGUAGE_NAME = 'Français'\n"
  },
  "directives": {
    "prefetch.ts": "// src/directives/prefetch.ts\nimport { type Directive, inject } from 'vue'\nimport { QueryClient, VUE_QUERY_CLIENT } from '@tanstack/vue-query'\nimport type { PrefetchOptions } from '@tanstack/vue-query'\n\n// Helper to check if the value is valid (basic check)\nfunction isValidBindingValue(value: any): value is PrefetchOptions {\n  return (\n    value &&\n    typeof value === 'object' &&\n    Array.isArray(value.queryKey) &&\n    typeof value.queryFn === 'function'\n  )\n}\n\nexport const vPrefetch: Directive<HTMLElement, PrefetchOptions | undefined> = {\n  mounted(el, binding) {\n    // --- Inject Client HERE in mounted ---\n    const queryClient = inject<QueryClient>(VUE_QUERY_CLIENT)\n\n    // --- Critical Check: Ensure client was injected ---\n    if (!queryClient) {\n      console.warn(\n        'v-prefetch mounted: QueryClient not available via inject(). Directive will not function.',\n      )\n      // Store a flag or null to indicate failure, preventing handler execution\n      ;(el as any).__vuePrefetchFailedInject__ = true\n      return // Stop setup if client cannot be injected\n    }\n    // Store the successfully injected client instance on the element\n    ;(el as any).__vueQueryClient__ = queryClient\n\n    // --- Validate and Store Initial Options ---\n    if (!isValidBindingValue(binding.value)) {\n      console.warn('v-prefetch mounted: Initial binding value is invalid.', binding.value)\n      // Store null options to prevent handler running with bad initial data\n      ;(el as any).__vuePrefetchOptions__ = null\n    } else {\n      // Store initial options if valid\n      ;(el as any).__vuePrefetchOptions__ = binding.value\n    }\n\n    // --- Define the Handler ---\n    const prefetchHandler = () => {\n      // --- Retrieve Client and Options from the element ---\n      // Check the failure flag first\n      if ((el as any).__vuePrefetchFailedInject__) {\n        // console.warn('v-prefetch handler: Aborting, QueryClient injection failed during mount.');\n        return\n      }\n      const client = (el as any).__vueQueryClient__ as QueryClient // Cast should be safe due to check above\n      const options = (el as any).__vuePrefetchOptions__ as PrefetchOptions | null\n\n      // Check if options are valid *at the time of execution*\n      if (!options || !isValidBindingValue(options)) {\n        console.warn(\n          'v-prefetch handler: Prefetch options not found or invalid on element at execution time.',\n        )\n        return\n      }\n      // --- End Retrieval & Validation ---\n\n      // console.debug('[v-prefetch handler] Triggered. Using queryClient from element:', client);\n      // console.debug('[v-prefetch handler] Prefetching options:', options);\n\n      // Use the retrieved 'client' instance\n      client.prefetchQuery(options).catch((err) => {\n        console.error('v-prefetch failed:', err)\n      })\n    }\n\n    // Store handler on the element to remove it later\n    ;(el as any).__vuePrefetchHandler__ = prefetchHandler\n\n    // Add listeners\n    el.addEventListener('mouseenter', prefetchHandler)\n    el.addEventListener('focus', prefetchHandler)\n  },\n\n  updated(el, binding) {\n    // Update stored options if they change and are valid\n    if (isValidBindingValue(binding.value)) {\n      ;(el as any).__vuePrefetchOptions__ = binding.value\n    } else {\n      // If updated options are invalid, store null to prevent handler execution\n      console.warn('v-prefetch updated: New binding value is invalid.', binding.value)\n      ;(el as any).__vuePrefetchOptions__ = null\n    }\n    // We assume the queryClient instance doesn't change after mount.\n  },\n\n  beforeUnmount(el) {\n    const handler = (el as any).__vuePrefetchHandler__\n    if (handler) {\n      el.removeEventListener('mouseenter', handler)\n      el.removeEventListener('focus', handler)\n      // Clean up stored properties\n      delete (el as any).__vuePrefetchHandler__\n      delete (el as any).__vuePrefetchOptions__\n      delete (el as any).__vueQueryClient__\n      delete (el as any).__vuePrefetchFailedInject__ // Clean up flag\n    }\n  },\n}\n"
  },
  "main.ts": "import { createApp, type Ref, computed } from 'vue' // Import Ref and computed if needed elsewhere, but not for composable defs\nimport { createPinia } from 'pinia'\nimport { VueQueryPlugin, VueQueryPluginOptions } from '@tanstack/vue-query' // Import Vue Query Plugin\n\nimport App from './App.vue'\nimport router from './router'\nimport './assets/main.css'\n// Correct the import path if you renamed the store file\nimport { useAuthStore } from './stores/auth.store'\nimport { vPrefetch } from './directives/prefetch'\n\nconst app = createApp(App)\nconst pinia = createPinia()\n\n// Vue Query Options (Optional)\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClientConfig: {\n    defaultOptions: {\n      queries: {\n        staleTime: 5 * 60 * 1000, // Default stale time for all queries (5 minutes)\n        gcTime: 10 * 60 * 1000, // Default garbage collection time (10 minutes)\n        refetchOnWindowFocus: false, // Optional: disable refetch on window focus\n      },\n    },\n  },\n}\n\napp.use(pinia)\napp.use(router)\napp.use(VueQueryPlugin, vueQueryPluginOptions)\n\napp.directive('prefetch', vPrefetch)\n\n// Initialize Auth Store (Corrected import name)\nconst authStore = useAuthStore() // Use the correct store name\nauthStore\n  .init()\n  .then(() => {\n    console.log('Auth initialized, mounting app.')\n    app.mount('#app')\n  })\n  .catch((error) => {\n    console.error('Failed to initialize application:', error)\n    // Handle critical initialization failure (e.g., show error message)\n    // Mounting anyway might lead to a broken state\n    app.mount('#app')\n  })\n",
  "router": {
    "index.ts": "/**\n * @file Vue Router configuration.\n * Defines application routes, navigation guards, and lazy loading.\n */\nimport {\n  createRouter,\n  createWebHistory,\n  type RouteRecordRaw,\n  type NavigationGuardNext,\n  type RouteLocationNormalized,\n} from 'vue-router'\nimport HomeView from '@/views/HomeView.vue'\nimport { fetchTestamentBySlug } from '@/services/apiService' // Use the service layer\n\n// Define route names as constants for type safety and easier refactoring\nconst RouteNames = {\n  HOME: 'home',\n  TESTAMENT_DETAIL: 'testament-detail',\n  GENRE_DETAIL: 'genre-detail',\n  BOOK_DETAIL: 'book-detail',\n  NOT_FOUND: 'not-found',\n} as const // Use 'as const' for stricter typing\n\nconst routes: Array<RouteRecordRaw> = [\n  {\n    path: '/',\n    name: RouteNames.HOME,\n    component: HomeView,\n  },\n  {\n    path: '/:testamentSlug', // More descriptive path segment\n    name: RouteNames.TESTAMENT_DETAIL,\n    // Lazy load view components for better initial load performance\n    component: () => import('@/views/TestamentView.vue'),\n    props: true, // Pass route params as props\n    // Navigation guard to validate slug and potentially fetch ID (though component composable handles it now)\n    // This guard primarily acts as validation before loading the component.\n    beforeEnter: async (\n      to: RouteLocationNormalized,\n      from: RouteLocationNormalized,\n      next: NavigationGuardNext,\n    ) => {\n      const slug = to.params.testamentSlug as string\n      console.debug(`Route Guard (${String(to.name)}): Validating testament slug: ${slug}`)\n      if (!slug) {\n        console.warn(`Route Guard (${String(to.name)}): Invalid slug provided.`)\n        return next({ name: RouteNames.NOT_FOUND }) // Redirect if slug is missing\n      }\n      try {\n        // Validate slug exists via API service - doesn't need to pass ID anymore\n        await fetchTestamentBySlug(slug)\n        console.debug(`Route Guard (${String(to.name)}): Slug validated successfully.`)\n        next() // Proceed to load the component\n      } catch (error) {\n        console.error(\n          `Route Guard (${String(to.name)}): Error validating testament slug '${slug}':`,\n          error,\n        )\n        // Handle specific errors, e.g., not found\n        if (error instanceof Error && error.message.includes('not found')) {\n          next({ name: RouteNames.NOT_FOUND }) // Redirect to NotFound view\n        } else {\n          // For other errors, maybe show a generic error page or pass error info\n          // For simplicity, redirecting to NotFound here too.\n          next({ name: RouteNames.NOT_FOUND })\n          // Or: next(new Error(`Failed to load testament: ${error.message}`)); // Pass error to global handler if set up\n        }\n      }\n    },\n  },\n  {\n    // Nested structure makes sense semantically\n    path: '/:testamentSlug/:genreSlug',\n    name: RouteNames.GENRE_DETAIL,\n    component: () => import('@/views/GenreDetailView.vue'),\n    props: true,\n    // Optional: Add a beforeEnter guard similar to testament if needed for genre slug validation\n  },\n  {\n    // Keep the full path for clarity, even if nested logically\n    path: '/:testamentSlug/:genreSlug/:bookSlug',\n    name: RouteNames.BOOK_DETAIL,\n    component: () => import('@/views/BookDetailView.vue'),\n    props: true,\n    // Optional: Add a beforeEnter guard similar to testament if needed for book slug validation\n  },\n  {\n    // Catch-all 404 route - Must be last\n    path: '/:pathMatch(.*)*',\n    name: RouteNames.NOT_FOUND,\n    component: () => import('@/views/NotFoundView.vue'),\n  },\n]\n\nconst router = createRouter({\n  history: createWebHistory(import.meta.env.BASE_URL),\n  routes,\n  // Optional: Add scroll behavior\n  scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition\n    } else if (to.hash) {\n      // If navigating with a hash, scroll to the element\n      return { el: to.hash, behavior: 'smooth' }\n    } else {\n      // Otherwise, scroll to the top of the page on new navigation\n      return { top: 0, behavior: 'smooth' }\n    }\n  },\n})\n\nexport default router\n"
  },
  "services": {
    "apiService.ts": "// src/services/apiService.ts\n/**\n * @file Centralized service for interacting with the Supabase database (Bible data).\n * Encapsulates all Supabase queries related to fetching biblical content,\n * adapted for the core_unit and core_xref schema.\n */\nimport supabase from '@/supabase'\nimport { getLanguageId } from '@/utils/language'\nimport type {\n  TestamentTranslation,\n  GenreTranslation,\n  BookSummary,\n  Chapter,\n  Version,\n  BaseVerse, // Use the updated BaseVerse\n  CccLinkResult, // Use the new RPC result type\n} from '@/types'\nimport { DEFAULT_LANGUAGE_NAME } from '@/constants'\n\n// Helper function to generate cleaned book label for ltree path\n// Based on the logic in verse_full_info_view\nfunction getCleanedBookLabel(abbr_ccc: string | null, abbr: string | null): string {\n  const rawLabel = abbr_ccc ?? abbr ?? 'unk_book'\n  let cleaned = rawLabel.replace(/[^a-zA-Z0-9_]+/g, '_')\n  if (cleaned.match(/^[0-9]/)) {\n    cleaned = 'b' + cleaned // Prepend 'b' if starts with a digit\n  }\n  return cleaned.toLowerCase() // Ensure lowercase for consistency if needed\n}\n\n/**\n * Fetches testament translations for the default language.\n *\n * @returns A promise resolving to an array of testament translations.\n * @throws If there's an error during the fetch or language ID retrieval.\n */\nexport async function fetchTestaments(): Promise<Omit<TestamentTranslation, 'lang_id'>[]> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n  const { data, error } = await supabase\n    .from('bible_testament_translations')\n    .select(\n      `\n      testament_id,\n      name,\n      slug\n    `,\n    )\n    .eq('lang_id', langId)\n    // Order based on the related table's ID if needed, or just by name\n    .order('name') // Assuming ordering by name is sufficient\n\n  if (error) {\n    console.error('Error fetching testaments:', error)\n    throw new Error(`Failed to fetch testaments: ${error.message}`)\n  }\n  // Type assertion might be needed if select structure differs slightly\n  return (data || []) as Omit<TestamentTranslation, 'lang_id'>[]\n}\n\n/**\n * Fetches details (name, ID) for a specific testament by its slug.\n *\n * @param slug - The URL slug of the testament.\n * @returns A promise resolving to the testament translation details.\n * @throws If the testament is not found or if there's a fetch error.\n */\nexport async function fetchTestamentBySlug(\n  slug: string,\n): Promise<Pick<TestamentTranslation, 'name' | 'testament_id'>> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n  const { data, error } = await supabase\n    .from('bible_testament_translations')\n    .select('name, testament_id') // testament_id is the FK to bible_testaments.id\n    .eq('slug', slug)\n    .eq('lang_id', langId)\n    .single()\n\n  if (error) {\n    console.error(`Error fetching testament by slug '${slug}':`, error)\n    if (error.code === 'PGRST116') {\n      throw new Error(`Testament with slug '${slug}' not found for the selected language.`)\n    }\n    throw new Error(`Failed to fetch testament details: ${error.message}`)\n  }\n  if (!data) {\n    throw new Error(`Testament with slug '${slug}' not found (no data returned).`)\n  }\n  return data\n}\n\n/**\n * Fetches distinct book genre translations associated with a specific testament.\n * (Logic remains similar, verify column names)\n * @param testamentId - The ID of the testament (bible_testaments.id).\n * @returns A promise resolving to an array of genre translations.\n * @throws If there's an error during the fetch.\n */\nexport async function fetchGenresForTestament(testamentId: number): Promise<GenreTranslation[]> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n\n  const { data: bookGenreData, error: bookGenreError } = await supabase\n    .from('bible_books')\n    .select('genre_id') // FK to bible_genres.id\n    .eq('testament_id', testamentId) // FK to bible_testaments.id\n    .not('genre_id', 'is', null)\n\n  if (bookGenreError) {\n    console.error(`Error fetching book genres for testament ${testamentId}:`, bookGenreError)\n    throw new Error(`Failed to fetch book genre associations: ${bookGenreError.message}`)\n  }\n\n  const distinctGenreIds = [\n    ...new Set(\n      bookGenreData?.map((item) => item.genre_id).filter((id): id is number => id !== null) ?? [],\n    ),\n  ]\n\n  if (distinctGenreIds.length === 0) {\n    return []\n  }\n\n  const { data: genreTranslationsData, error: translationError } = await supabase\n    .from('bible_genre_translations')\n    .select('name, slug, genre_id') // genre_id is FK\n    .in('genre_id', distinctGenreIds)\n    .eq('lang_id', langId)\n    .order('name')\n\n  if (translationError) {\n    console.error(\n      `Error fetching genre translations for testament ${testamentId}:`,\n      translationError,\n    )\n    throw new Error(`Failed to fetch genre names: ${translationError.message}`)\n  }\n\n  // Map to ensure the type matches, removing translation-specific id if present\n  return (genreTranslationsData || []).map((g) => ({\n    genre_id: g.genre_id,\n    lang_id: langId, // Add lang_id back if needed by the type, though it was filtered\n    name: g.name,\n    slug: g.slug,\n  }))\n}\n\n/**\n * Fetches details (name, ID) for a specific book genre by its slug.\n * (Verify column names)\n * @param slug - The URL slug of the book genre.\n * @returns A promise resolving to the genre translation details.\n * @throws If the genre is not found or if there's a fetch error.\n */\nexport async function fetchGenreBySlug(\n  slug: string,\n): Promise<Pick<GenreTranslation, 'name' | 'genre_id'>> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n  const { data, error } = await supabase\n    .from('bible_genre_translations')\n    .select('name, genre_id') // genre_id is FK\n    .eq('slug', slug)\n    .eq('lang_id', langId)\n    .single()\n\n  if (error) {\n    console.error(`Error fetching genre by slug '${slug}':`, error)\n    if (error.code === 'PGRST116') {\n      throw new Error(`Genre with slug '${slug}' not found for the selected language.`)\n    }\n    throw new Error(`Failed to fetch genre details: ${error.message}`)\n  }\n  if (!data) {\n    throw new Error(`Genre with slug '${slug}' not found (no data returned).`)\n  }\n  return data\n}\n\n/**\n * Fetches books belonging to a specific genre ID, including their translations.\n * Adapted for new schema (PK is 'id').\n * @param genreId - The ID of the book genre (bible_genres.id).\n * @returns A promise resolving to an array of book summaries.\n * @throws If there's an error during the fetch.\n */\nexport async function fetchBooksByGenre(genreId: number): Promise<BookSummary[]> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n  const { data, error } = await supabase\n    .from('bible_books') // Base table\n    .select(\n      `\n      id,\n      bible_order,\n      bible_book_translations!inner (\n          title,\n          abbr,\n          slug,\n          lang_id,\n          abbr_ccc\n      )\n    `,\n    )\n    .eq('genre_id', genreId)\n    .eq('bible_book_translations.lang_id', langId) // Filter joined translations\n    .order('bible_order')\n\n  if (error) {\n    console.error(`Error fetching books for genre ${genreId}:`, error)\n    throw new Error(`Failed to fetch books: ${error.message}`)\n  }\n\n  // Map to the BookSummary structure\n  return (data || [])\n    .filter(\n      (book) =>\n        book.bible_book_translations &&\n        Array.isArray(book.bible_book_translations) &&\n        book.bible_book_translations.length > 0,\n    )\n    .map((book) => {\n      const translation = book.bible_book_translations[0] // Should be only one due to inner join and lang filter\n      const cleanedLabel = getCleanedBookLabel(translation?.abbr_ccc, translation?.abbr)\n      return {\n        book_id: book.id, // Map id to book_id for frontend consistency\n        bible_order: book.bible_order,\n        title: translation?.title || 'Unknown Title',\n        abbr: translation?.abbr || 'N/A',\n        slug: translation?.slug || `book-${book.id}`, // Fallback slug\n        cleaned_book_label: cleanedLabel,\n      }\n    })\n}\n\n/**\n * Fetches details (title, ID, label) for a specific book by its slug.\n * Adapted for new schema.\n * @param slug - The URL slug of the book.\n * @returns A promise resolving to the book details needed for display and path construction.\n * @throws If the book is not found or if there's a fetch error.\n */\nexport async function fetchBookBySlug(\n  slug: string,\n): Promise<{ book_id: number; title: string; cleaned_book_label: string }> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n  const { data, error } = await supabase\n    .from('bible_book_translations')\n    .select('title, book_id, abbr, abbr_ccc') // book_id is the FK to bible_books.id\n    .eq('slug', slug)\n    .eq('lang_id', langId)\n    .single()\n\n  if (error) {\n    console.error(`Error fetching book by slug '${slug}':`, error)\n    if (error.code === 'PGRST116') {\n      throw new Error(`Book with slug '${slug}' not found for the selected language.`)\n    }\n    throw new Error(`Failed to fetch book details: ${error.message}`)\n  }\n  if (!data || data.book_id === null) {\n    throw new Error(`Book with slug '${slug}' not found or missing book ID.`)\n  }\n\n  const cleanedLabel = getCleanedBookLabel(data.abbr_ccc, data.abbr)\n\n  return {\n    book_id: data.book_id as number, // Cast book_id\n    title: data.title,\n    cleaned_book_label: cleanedLabel,\n  }\n}\n\n/**\n * Fetches available Bible versions for the default language.\n * Adapted for new schema (PK is 'id').\n * @returns A promise resolving to an array of versions.\n * @throws If there's an error during the fetch.\n */\nexport async function fetchAvailableVersions(): Promise<Version[]> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n  const { data, error } = await supabase\n    .from('bible_versions')\n    .select('id, abbr, full_name, lang_id') // Select PK 'id'\n    .eq('lang_id', langId)\n    .order('abbr')\n\n  if (error) {\n    console.error('Error fetching available versions:', error)\n    throw new Error(`Failed to load versions: ${error.message}`)\n  }\n  // Map to Version type, changing 'id' to 'version_id' if needed by frontend type,\n  // but it's better to update the frontend type to use 'id'.\n  // Sticking with the updated type:\n  return (data || []).map((v) => ({\n    id: v.id,\n    abbr: v.abbr,\n    full_name: v.full_name,\n    lang_id: v.lang_id,\n  }))\n}\n\n/**\n * Fetches chapter numbers for a specific book ID and version code.\n * Queries core_unit using ltree to find distinct chapter numbers.\n *\n * @param bookId - The ID of the book (bible_books.id).\n * @param bookLabel - The cleaned book label for the ltree path (e.g., 'gen').\n * @param versionCode - The version code for the ltree path (e.g., 'vul').\n * @returns A promise resolving to an array of chapter numbers.\n * @throws If there's an error during the fetch.\n */\nexport async function fetchChaptersForBook(\n  bookId: number, // Keep bookId for context if needed\n  bookLabel: string,\n  versionCode: string,\n): Promise<number[]> {\n  const parentPath = `bib.${versionCode}.${bookLabel}`\n  // Query distinct chapter numbers (4th level of the path) under the book path\n  const { data, error } = await supabase\n    .from('core_unit')\n    .select('path')\n    .like('path', `${parentPath}.*`) // Ensure it's under the book\n    .eq('unit_type', 'verse') // Look at verses to determine chapters\n  // .filter('nlevel(path)', 'eq', 5) // Verses are level 5: bib.ver.book.chap.verse\n  // Alternative: Use RPC or more complex query if performance is an issue\n\n  if (error) {\n    console.error(\n      `Error fetching chapters for book ${bookLabel} (ID ${bookId}), version ${versionCode}:`,\n      error,\n    )\n    throw new Error(`Failed to load chapters: ${error.message}`)\n  }\n\n  if (!data) {\n    return []\n  }\n\n  // Extract chapter numbers (4th component) from the paths of verses (5th level)\n  const chapterNumbers = new Set<number>()\n  data.forEach((item) => {\n    const pathString = item.path as string // Assuming path is returned as string\n    const parts = pathString.split('.')\n    // Path: bib.vul.gen.1.1 (length 5) -> Chapter is parts[3]\n    if (parts.length >= 4) {\n      const chapterNum = parseInt(parts[3], 10)\n      if (!isNaN(chapterNum)) {\n        chapterNumbers.add(chapterNum)\n      }\n    }\n  })\n\n  // Sort and return the distinct chapter numbers\n  return Array.from(chapterNumbers).sort((a, b) => a - b)\n}\n\n/**\n * Fetches verses for a specific chapter using ltree path.\n *\n * @param bookLabel - The cleaned book label (e.g., 'gen').\n * @param chapterNumber - The chapter number.\n * @param versionCode - The version code (e.g., 'vul').\n * @returns A promise resolving to an array of verses.\n * @throws If there's an error during the fetch.\n */\nexport async function fetchVersesForChapter(\n  bookLabel: string,\n  chapterNumber: number,\n  versionCode: string,\n): Promise<BaseVerse[]> {\n  const chapterPath = `bib.${versionCode}.${bookLabel}.${chapterNumber}`\n  console.debug(`[fetchVersesForChapter] Querying path: ${chapterPath}.*`)\n\n  const { data, error } = await supabase\n    .from('core_unit')\n    .select('id, unit_type, canonical_ref, sort_order, content_text, path')\n    .like('path', `${chapterPath}.*`) // Match verses within the chapter path\n    .eq('unit_type', 'verse')\n    .order('path') // Order by full path ensures correct verse order\n\n  if (error) {\n    console.error(`Error fetching verses for ${chapterPath}:`, error)\n    throw new Error(`Failed to load verses (DB error: ${error.message})`)\n  }\n\n  // Map to BaseVerse structure\n  return (data || []).map((item) => ({\n    id: item.id,\n    unit_type: 'verse',\n    canonical_ref: item.canonical_ref,\n    sort_order: item.sort_order, // Verse number\n    content_text: item.content_text,\n    path: item.path as string, // Cast path if needed\n  }))\n}\n\n/**\n * Fetches Catechism paragraph numbers (sort_order) linked to a given list of verse IDs (core_unit.id)\n * using a new RPC function 'get_ccc_nums_for_verse_ids'.\n *\n * @param verseIds - An array of verse core_unit IDs to look up.\n * @returns A promise resolving to a Map where keys are verse IDs and values are arrays of corresponding ccc_nums.\n * @throws If there's an error during the RPC call.\n */\nexport async function fetchCatechismLinksViaRpc(\n  verseIds: number[],\n): Promise<Map<number, number[]>> {\n  if (!verseIds || verseIds.length === 0) {\n    return new Map() // Return empty map if no IDs are provided\n  }\n\n  console.debug(\n    `[fetchCatechismLinksViaRpc] Calling RPC 'get_ccc_nums_for_verse_ids' for ${verseIds.length} verse IDs.`,\n  )\n\n  // *** IMPORTANT: You need to create this RPC function in your Supabase SQL editor ***\n  /*\n  -- Example SQL for the RPC function:\n  CREATE OR REPLACE FUNCTION public.get_ccc_nums_for_verse_ids(target_verse_ids bigint[])\n  RETURNS TABLE(verse_id bigint, ccc_nums integer[])\n  LANGUAGE sql\n  STABLE -- Or VOLATILE depending on exact logic and potential side effects\n  AS $function$\n      SELECT\n          xref.src_id as verse_id,\n          -- Aggregate the sort_order (paragraph number) from the linked CCC paragraphs\n          array_agg(linked_para.sort_order ORDER BY linked_para.sort_order)::integer[] as ccc_nums\n      FROM\n          public.core_xref xref\n      JOIN\n          public.core_unit linked_para ON xref.dst_id = linked_para.id\n      WHERE\n          xref.src_id = ANY(target_verse_ids)\n          AND xref.rel_type_id = 'bible_to_ccc' -- <<< VERIFY THIS RELATION TYPE ID in xref_relation table\n          AND linked_para.unit_type = 'ccc_para'\n      GROUP BY\n          xref.src_id;\n  $function$;\n  -- Grant execution permission if needed:\n  -- GRANT EXECUTE ON FUNCTION public.get_ccc_nums_for_verse_ids(bigint[]) TO authenticated;\n  -- GRANT EXECUTE ON FUNCTION public.get_ccc_nums_for_verse_ids(bigint[]) TO anon; -- If public access needed\n  */\n\n  const { data, error } = await supabase.rpc('get_ccc_nums_for_verse_ids', {\n    // Ensure the argument name matches the RPC function definition\n    target_verse_ids: verseIds,\n  })\n\n  if (error) {\n    console.error('Error calling get_ccc_nums_for_verse_ids RPC:', error)\n    throw new Error(`Failed to fetch Catechism links via RPC: ${error.message}`)\n  }\n\n  // Process the RPC result\n  const indexMap = new Map<number, number[]>()\n  if (data) {\n    const results = data as CccLinkResult[] // Use the defined type\n    for (const result of results) {\n      if (result.verse_id && result.ccc_nums && result.ccc_nums.length > 0) {\n        indexMap.set(result.verse_id, result.ccc_nums)\n      }\n    }\n  }\n\n  console.debug(\n    `[apiService] Fetched Catechism links via RPC for ${verseIds.length} verse IDs. Found links for ${indexMap.size} verses.`,\n  )\n  return indexMap\n}\n\n// Remove the old fetchCatechismLinksForVerseIds function\n// export async function fetchCatechismLinksForVerseIds(...) { ... }\n"
  },
  "stores": {
    "auth.store.ts": "/**\n * @file Pinia store for managing Supabase authentication state and actions.\n */\nimport { defineStore } from 'pinia'\nimport { ref, computed, type Ref } from 'vue'\nimport supabase from '@/supabase'\nimport type {\n  AuthError,\n  Session,\n  User,\n  SignInWithPasswordCredentials,\n  SignUpWithPasswordCredentials,\n} from '@supabase/supabase-js'\n\n// Define the state structure with explicit types\ninterface AuthState {\n  user: User | null\n  session: Session | null\n  isLoading: boolean\n  error: string | null\n}\n\nexport const useAuthStore = defineStore('auth', () => {\n  // --- State ---\n  const user: Ref<User | null> = ref(null)\n  const session: Ref<Session | null> = ref(null)\n  const isLoading: Ref<boolean> = ref(false)\n  const error: Ref<string | null> = ref(null)\n\n  // --- Getters ---\n  const isLoggedIn = computed<boolean>(() => !!user.value)\n  const userId = computed<string | undefined>(() => user.value?.id)\n\n  // --- Internal Actions ---\n\n  /**\n   * Sets the error message and clears it after a delay.\n   * @param errorMessage - The error message string.\n   * @param timeoutMs - Duration in milliseconds before clearing the error. Defaults to 5000.\n   */\n  function setError(errorMessage: string | null, timeoutMs = 5000): void {\n    error.value = errorMessage\n    if (errorMessage !== null) {\n      setTimeout(() => {\n        if (error.value === errorMessage) {\n          // Clear only if it hasn't been overwritten\n          error.value = null\n        }\n      }, timeoutMs)\n    }\n  }\n\n  /**\n   * Centralized loading state management.\n   * @param loading - Boolean indicating the loading state.\n   */\n  function setLoading(loading: boolean): void {\n    isLoading.value = loading\n  }\n\n  /**\n   * Updates the user and session state.\n   * @param newSession - The new session object from Supabase, or null.\n   */\n  function updateAuthState(newSession: Session | null): void {\n    session.value = newSession\n    user.value = newSession?.user ?? null\n    console.debug('Auth state updated:', event, newSession)\n  }\n\n  // --- Actions ---\n\n  /**\n   * Initializes the auth state by fetching the current session and setting up the listener.\n   * Should be called once when the application starts.\n   */\n  async function init(): Promise<void> {\n    setLoading(true)\n    setError(null)\n    console.debug('Initializing auth store...')\n    try {\n      // Attempt to get the initial session\n      const { data: initialSessionData, error: sessionError } = await supabase.auth.getSession()\n      if (sessionError) {\n        console.error('Error getting initial session:', sessionError)\n        // Don't throw here, allow app to load, but log the error\n        setError(`Failed to retrieve initial session: ${sessionError.message}`)\n      } else {\n        updateAuthState(initialSessionData.session)\n      }\n\n      // Set up listener for subsequent auth changes\n      const { data: authListener } = supabase.auth.onAuthStateChange((event, newSession) => {\n        updateAuthState(newSession)\n      })\n\n      // Consider storing the subscription to unsubscribe on app teardown if needed\n      // E.g., store `authListener.subscription` and call `unsubscribe()` later.\n      console.debug('Auth listener attached.')\n    } catch (err) {\n      console.error('Critical error during auth initialization:', err)\n      setError(err instanceof Error ? err.message : 'An unknown error occurred during auth setup.')\n      // Update state to reflect failure\n      updateAuthState(null)\n    } finally {\n      setLoading(false)\n      console.debug('Auth store initialization complete.')\n    }\n  }\n\n  /**\n   * Signs in a user using email and password.\n   * @param credentials - Object containing email and password.\n   * @returns A promise resolving to an object indicating success or failure.\n   */\n  async function signInWithEmail(\n    credentials: SignInWithPasswordCredentials,\n  ): Promise<{ success: boolean; error?: AuthError }> {\n    setLoading(true)\n    setError(null)\n    try {\n      const { data, error: authError } = await supabase.auth.signInWithPassword(credentials)\n\n      if (authError) {\n        console.error('Sign-in error:', authError)\n        throw authError // Throw to be caught below\n      }\n\n      // Auth state will be updated by the onAuthStateChange listener\n      // updateAuthState(data.session); // Avoid redundant update if listener works reliably\n      return { success: true }\n    } catch (err) {\n      const authError = err as AuthError\n      setError(authError.message || 'Failed to sign in.')\n      console.error('Sign in action failed:', authError)\n      return { success: false, error: authError }\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  /**\n   * Signs up a new user using email and password.\n   * @param credentials - Object containing email and password.\n   * @returns A promise resolving to an object indicating success or failure.\n   */\n  async function signUpWithEmail(\n    credentials: SignUpWithPasswordCredentials,\n  ): Promise<{ success: boolean; error?: AuthError }> {\n    setLoading(true)\n    setError(null)\n    try {\n      // Note: Supabase might require email confirmation depending on settings.\n      // The user object in the response might be null until confirmed.\n      const { data, error: authError } = await supabase.auth.signUp(credentials)\n\n      if (authError) {\n        console.error('Sign-up error:', authError)\n        throw authError\n      }\n\n      // User might need to confirm email. State might not update immediately.\n      console.log('Sign-up successful (check email for confirmation if enabled). User:', data.user)\n      return { success: true }\n    } catch (err) {\n      const authError = err as AuthError\n      setError(authError.message || 'Failed to sign up.')\n      console.error('Sign up action failed:', authError)\n      return { success: false, error: authError }\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  /**\n   * Signs out the current user.\n   * @returns A promise resolving to an object indicating success or failure.\n   */\n  async function signOut(): Promise<{ success: boolean; error?: AuthError }> {\n    setLoading(true)\n    setError(null)\n    try {\n      const { error: authError } = await supabase.auth.signOut()\n\n      if (authError) {\n        console.error('Sign-out error:', authError)\n        throw authError\n      }\n\n      // Auth state will be updated by the onAuthStateChange listener\n      // updateAuthState(null); // Avoid redundant update\n      return { success: true }\n    } catch (err) {\n      const authError = err as AuthError\n      setError(authError.message || 'Failed to sign out.')\n      console.error('Sign out action failed:', authError)\n      return { success: false, error: authError }\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  // --- Return Store API ---\n  return {\n    // State refs (read-only recommended for direct use in components)\n    user: computed(() => user.value), // Expose as computed for read-only access\n    session: computed(() => session.value),\n    isLoading: computed(() => isLoading.value),\n    error: computed(() => error.value),\n\n    // Getters\n    isLoggedIn,\n    userId,\n\n    // Actions\n    init,\n    signInWithEmail,\n    signUpWithEmail,\n    signOut,\n  }\n})\n"
  },
  "supabase.ts": "/**\n * @file Initializes and exports the Supabase client instance.\n */\nimport { createClient, SupabaseClient } from '@supabase/supabase-js'\nimport type { Database } from './types/supabase'\n\nconst supabaseUrl: string | undefined = import.meta.env.VITE_SUPABASE_URL\nconst supabaseAnonKey: string | undefined = import.meta.env.VITE_SUPABASE_ANON_KEY\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  const errorMessage =\n    'Supabase environment variables are missing. Make sure VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY are set in your .env file.'\n  console.error(errorMessage)\n  // In a real app, you might want to show this error to the user or halt initialization gracefully.\n  throw new Error('Supabase configuration is incomplete.')\n}\n\n// Initialize the Supabase client with generated types for better type safety\nconst supabase: SupabaseClient<Database> = createClient<Database>(supabaseUrl, supabaseAnonKey)\n\nexport default supabase\n",
  "types": {
    "api.ts": "// src/types/api.ts\n// REMOVE or MODIFY existing interfaces for Chapter, Verse, BaseVerse, CatechismBibleIndexEntry\n// ADD or MODIFY based on core_unit and new relationships\n\n/**\n * @file TypeScript interfaces for API data structures reflecting the refactored schema.\n */\n\nexport interface Language {\n  // Changed lang_id to id based on languages table PK\n  id: number\n  lang: string\n  code: string\n}\n\nexport interface TestamentTranslation {\n  // Removed testament_translation_id (PK is now id, not needed directly often)\n  // testament_id is the FK to bible_testaments.id\n  testament_id: number\n  lang_id: number\n  name: string\n  slug: string\n  // Optional relation if needed, points to bible_testaments\n  // bible_testaments?: { id: number; canonical_identifier: string };\n}\n\nexport interface GenreTranslation {\n  // Removed genre_translation_id\n  genre_id: number // FK to bible_genres.id\n  lang_id: number\n  name: string\n  slug: string\n}\n\nexport interface BookSummary {\n  book_id: number // This now corresponds to bible_books.id\n  bible_order: number\n  title: string\n  abbr: string\n  slug: string\n  // Add the 'cleaned label' needed for ltree paths\n  cleaned_book_label: string\n}\n\n// Representing a verse from core_unit\nexport interface BaseVerse {\n  id: number // Corresponds to core_unit.id\n  unit_type: 'verse'\n  canonical_ref: string\n  sort_order: number // This is the verse number\n  content_text: string | null\n  // Removed version_id, chapter_id as they are implicit in path/context\n  // Removed reference_id\n  // Add path for potential debugging or advanced usage\n  path: string // ltree path as text\n}\n\nexport interface Verse extends BaseVerse {\n  cccParagraphNumbers?: number[] // Holds linked CCC paragraph numbers (sort_order)\n}\n\nexport interface Version {\n  id: number // Corresponds to bible_versions.id\n  lang_id: number\n  abbr: string // Used as version_code in ltree paths\n  full_name: string\n}\n\n// Add type for the new RPC result\nexport interface CccLinkResult {\n  verse_id: number // core_unit.id of the verse\n  ccc_nums: number[] | null // Array of sort_order from linked ccc_para units\n}\n\n// Optional: If querying ccc_para_view directly\nexport interface CccParaViewData {\n  id: number\n  ccc_ref: string\n  ccc_number: number // sort_order\n  content_text: string | null\n  content_html: string | null\n  lang_id: number\n  fts: any // tsvector type\n  bible_ref_ids: number[] // Array of core_unit.id for linked verses\n  ccc_ref_ids: number[] // Array of core_unit.id for linked paras\n}\n",
    "index.ts": "/**\n * @file Barrel file for exporting all types.\n */\nexport * from './api'\nexport * from './vue'\n",
    "vue.ts": "/**\n * @file Common Vue related type definitions (Props, Emits).\n */\n\n// Example Prop Type (adjust as needed per component)\nexport interface ExampleComponentProps {\n  message: string\n  count?: number\n}\n\n// Example Emit Type (adjust as needed per component)\nexport type ExampleComponentEmits = {\n  update: [value: string] // Emits 'update' with a string payload\n  close: [] // Emits 'close' with no payload\n}\n"
  },
  "utils": {
    "language.ts": "// src/utils/language.ts\n// Update the query to use `id` instead of `lang_id`\nimport supabase from '@/supabase'\nimport { DEFAULT_LANGUAGE_NAME } from '@/constants'\n\nconst languageIdCache: Record<string, number> = {}\n\nexport const getLanguageId = async (langName: string = DEFAULT_LANGUAGE_NAME): Promise<number> => {\n  if (languageIdCache[langName]) {\n    return languageIdCache[langName]\n  }\n\n  console.debug(`Fetching language ID for: ${langName}`)\n  try {\n    const { data, error } = await supabase\n      .from('languages')\n      .select('id') // Select the primary key 'id'\n      .eq('lang', langName)\n      .single()\n\n    if (error) {\n      console.error(`Supabase error fetching language ID for ${langName}:`, error)\n      throw new Error(`Database error fetching language ID: ${error.message}`)\n    }\n    if (!data) {\n      throw new Error(`Language '${langName}' not found in the database.`)\n    }\n\n    console.debug(`Found language ID for ${langName}: ${data.id}`) // Use data.id\n    languageIdCache[langName] = data.id // Use data.id\n    return data.id // Return data.id\n  } catch (err) {\n    console.error(`Error in getLanguageId for ${langName}:`, err)\n    if (err instanceof Error) {\n      throw err\n    } else {\n      throw new Error(`An unknown error occurred while fetching language ID for ${langName}.`)\n    }\n  }\n}\n",
    "prefetchHelpers.ts": "// src/utils/prefetchHelpers.ts\n// This needs significant updates due to changes in how chapters/verses are fetched\n\nimport { inject } from 'vue'\nimport { QueryClient, VUE_QUERY_CLIENT } from '@tanstack/vue-query'\nimport * as apiService from '@/services/apiService' // Import the updated service\nimport type { PrefetchOptions } from '@tanstack/vue-query'\nimport type { BaseVerse, Version } from '@/types' // Import updated types\n\n// Helper to find version code, defaulting to ID 1 if available\nfunction getDefaultVersionCode(versions: Version[] | null | undefined): string | null {\n  if (!versions || versions.length === 0) return null\n  // Assuming version ID 1 is the default/preferred (e.g., Vulgata Latina)\n  const defaultVersion = versions.find((v) => v.id === 1) || versions[0]\n  return defaultVersion.abbr // Use the abbreviation as the code\n}\n\n/**\n * Creates prefetch options for navigating to a Book Detail view.\n * Prefetches book details, versions, first chapter number, first chapter base verses,\n * and the Catechism links for the first chapter's verses.\n *\n * @param bookSlug - The slug of the book to prefetch details for.\n * @returns An object containing queryKey, queryFn, and staleTime suitable for prefetch.\n */\nexport function createBookPrefetchOptions(bookSlug: string): PrefetchOptions {\n  const primaryQueryKey = ['book_detail', bookSlug]\n\n  const combinedQueryFn = async () => {\n    const queryClient = inject<QueryClient>(VUE_QUERY_CLIENT)\n    if (!queryClient) {\n      console.warn('[Prefetch Helper] QueryClient not available.')\n      return null // Cannot proceed without client\n    }\n\n    console.debug(`[Prefetch Helper] Running prefetch sequence for slug: ${bookSlug}`)\n    try {\n      // Prefetch Versions first, as we need the code\n      const versions = await queryClient.fetchQuery<Version[]>({\n        queryKey: ['bible_versions'],\n        queryFn: apiService.fetchAvailableVersions,\n        staleTime: 10 * 60 * 1000,\n      })\n\n      const defaultVersionCode = getDefaultVersionCode(versions)\n      if (!defaultVersionCode) {\n        console.warn(\n          `[Prefetch Helper] Could not determine default version code, stopping prefetch.`,\n        )\n        return null\n      }\n      // Use default Version ID 1 for verse prefetch target\n      const defaultVersionId = versions?.find((v) => v.abbr === defaultVersionCode)?.id ?? null\n      if (!defaultVersionId) {\n        console.warn(`[Prefetch Helper] Could not determine default version ID, stopping prefetch.`)\n        return null\n      }\n\n      // Step 1: Book Details (provides book_id and cleaned_book_label)\n      const bookDetails = await queryClient.fetchQuery({\n        queryKey: primaryQueryKey,\n        queryFn: () => apiService.fetchBookBySlug(bookSlug), // Returns { book_id, title, cleaned_book_label }\n        staleTime: 5 * 60 * 1000,\n      })\n\n      if (bookDetails?.book_id && bookDetails?.cleaned_book_label) {\n        const bookId = bookDetails.book_id\n        const bookLabel = bookDetails.cleaned_book_label\n\n        // Step 2: Fetch Chapter Numbers\n        const chapterNumbers = await queryClient.fetchQuery({\n          queryKey: ['chapter_numbers', bookId, bookLabel, defaultVersionCode],\n          queryFn: () => apiService.fetchChaptersForBook(bookId, bookLabel, defaultVersionCode),\n          staleTime: 10 * 60 * 1000,\n        })\n\n        if (chapterNumbers && chapterNumbers.length > 0) {\n          const firstChapterNumber = chapterNumbers[0]\n\n          // Step 3: Prefetch Base Verses for the first chapter\n          const firstChapterVerses = await queryClient.fetchQuery<BaseVerse[]>({\n            queryKey: ['verseText', bookLabel, firstChapterNumber, defaultVersionCode],\n            queryFn: () =>\n              apiService.fetchVersesForChapter(bookLabel, firstChapterNumber, defaultVersionCode),\n            staleTime: 5 * 60 * 1000,\n          })\n\n          // Step 4: If verses were fetched, prefetch their CCC Links\n          if (firstChapterVerses && firstChapterVerses.length > 0) {\n            const verseIds = firstChapterVerses.map((v) => v.id) // Use the new 'id' field\n            console.debug(\n              `[Prefetch Helper]   Prefetching CCC links via RPC for ${verseIds.length} verses from Ch ${firstChapterNumber}.`,\n            )\n            await queryClient\n              .prefetchQuery({\n                // Ensure key matches the one used in useCatechismLinksForVerses\n                queryKey: ['cccLinks', verseIds.sort((a, b) => a - b).join(',')],\n                queryFn: () => apiService.fetchCatechismLinksViaRpc(verseIds),\n                staleTime: 5 * 60 * 1000,\n              })\n              .catch((err) => {\n                console.warn(`[Prefetch Helper]   CCC links prefetch failed:`, err?.message ?? err)\n              })\n          } else {\n            console.debug(\n              `[Prefetch Helper]   No verses found for Ch ${firstChapterNumber}, skipping CCC link prefetch.`,\n            )\n          }\n        } else {\n          console.debug(\n            `[Prefetch Helper]   No chapters found for book ${bookLabel}, skipping verse/link prefetch.`,\n          )\n        }\n      } else {\n        console.warn(\n          `[Prefetch Helper] Could not get book_id/label for slug ${bookSlug}, skipping secondary fetches.`,\n        )\n      }\n      return bookDetails // Return primary data\n    } catch (error: any) {\n      console.error(\n        `[Prefetch Helper] Error during prefetch sequence for slug ${bookSlug}:`,\n        error?.message ?? error,\n      )\n      throw error // Re-throw\n    }\n  }\n\n  return {\n    queryKey: primaryQueryKey,\n    queryFn: combinedQueryFn,\n    staleTime: 60 * 1000, // Stale time for the combined operation trigger\n  }\n}\n"
  },
  "views": {
    "BookDetailView.vue": "<!-- src/views/BookDetailView.vue -->\n<template>\n  <div class=\"book-detail-view container\">\n    <header class=\"view-header book-header\">\n      <!-- Book Loading/Error -->\n      <BaseLoadingIndicator v-if=\"isLoadingBook\" message=\"Loading book details...\" />\n      <BaseErrorMessage v-if=\"isErrorBook\" :message=\"errorBook?.message\" />\n\n      <template v-if=\"bookDetails\">\n        <h1>{{ bookDetails.title }}</h1>\n\n        <!-- Version Loading/Error/Selection -->\n        <BaseLoadingIndicator v-if=\"isLoadingVersions\" message=\"Loading versions...\" />\n        <BaseErrorMessage v-if=\"isErrorVersions\" :message=\"errorVersions?.message\" />\n        <div v-if=\"versions && versions.length > 1\" class=\"version-selector\">\n          <label for=\"versionSelect\">Version:</label>\n          <select id=\"versionSelect\" v-model=\"selectedVersionId\">\n            <option :value=\"null\" disabled>Select Version</option>\n            <!-- Use version.id for the value -->\n            <option v-for=\"version in versions\" :key=\"version.id\" :value=\"version.id\">\n              {{ version.abbr }} ({{ version.full_name }})\n            </option>\n          </select>\n        </div>\n        <p v-if=\"versions && versions.length === 1\" class=\"single-version\">\n          <!-- Use version.id for the key -->\n          Version: {{ versions[0].abbr }}\n        </p>\n        <p v-if=\"!isLoadingVersions && !isErrorVersions && (!versions || versions.length === 0)\" class=\"no-results\">\n          No Bible versions found.\n        </p>\n      </template>\n      <h1 v-if=\"!isLoadingBook && !isErrorBook && !bookDetails\">Book Not Found</h1>\n    </header>\n\n    <!-- Main content requires book, version, and chapter to be selected/loaded -->\n    <main v-if=\"bookDetails && selectedVersionCode && chapterNumbers !== undefined\">\n\n      <!-- Chapter Loading/Error/Navigation -->\n      <BaseLoadingIndicator v-if=\"isLoadingChapters\" message=\"Loading chapters...\" />\n      <BaseErrorMessage v-if=\"isErrorChapters\" :message=\"errorChapters?.message\" />\n      <nav v-if=\"chapterNumbers && chapterNumbers.length > 1\" class=\"chapter-nav\">\n        <button @click=\"changeChapter(-1)\"\n          :disabled=\"!selectedChapterNumber || selectedChapterNumber <= chapterNumbers[0]\"\n          aria-label=\"Previous Chapter\">\n          < Prev </button>\n            <span role=\"status\" aria-live=\"polite\">\n              Chapter {{ selectedChapterNumber ?? '...' }} of {{ chapterNumbers.length }}\n            </span>\n            <button @click=\"changeChapter(1)\"\n              :disabled=\"!selectedChapterNumber || selectedChapterNumber >= chapterNumbers[chapterNumbers.length - 1]\"\n              aria-label=\"Next Chapter\">\n              Next >\n            </button>\n      </nav>\n      <h2 v-else-if=\"chapterNumbers && chapterNumbers.length === 1\" class=\"single-chapter-heading\">\n        Chapter {{ chapterNumbers[0] }}\n      </h2>\n      <p v-if=\"!isLoadingChapters && !isErrorChapters && chapterNumbers && chapterNumbers.length === 0\"\n        class=\"no-results\">\n        No chapters found for this book in the selected version.\n      </p>\n\n      <!-- Verse Loading/Error/Display -->\n      <div v-if=\"selectedChapterNumber\" class=\"content-area\">\n        <!-- Combined loading indicator -->\n        <BaseLoadingIndicator v-if=\"isLoadingVersesCombinedDelayed\" message=\"Loading content...\" />\n        <!-- Combined error message -->\n        <BaseErrorMessage v-if=\"combinedVerseError\" :message=\"combinedVerseError\" />\n\n        <div v-if=\"!isLoadingVersesCombined && !combinedVerseError && versesWithLinks && versesWithLinks.length > 0\"\n          class=\"verses-container\">\n          <!-- Iterate over versesWithLinks -->\n          <p v-for=\"verse in versesWithLinks\" :key=\"verse.id\" class=\"verse\">\n            <!-- Use sort_order for verse number, id for key -->\n            <sup :id=\"`v${selectedChapterNumber}-${verse.sort_order}`\">{{ verse.sort_order }}</sup>\n            {{ verse.content_text }}\n            <!-- Use verse.cccParagraphNumbers -->\n            <span v-if=\"verse.cccParagraphNumbers && verse.cccParagraphNumbers.length > 0\" class=\"ccc-link-indicator\"\n              :title=\"`Links to CCC: ${verse.cccParagraphNumbers.join(', ')}`\" role=\"link\" tabindex=\"0\"\n              @click=\"showCatechismLinks(verse.cccParagraphNumbers)\"\n              @keydown.enter=\"showCatechismLinks(verse.cccParagraphNumbers)\"\n              @keydown.space.prevent=\"showCatechismLinks(verse.cccParagraphNumbers)\">\n              [CCC]\n            </span>\n          </p>\n        </div>\n        <p v-if=\"!isLoadingVersesCombined && !combinedVerseError && versesWithLinks && versesWithLinks.length === 0 && chapterNumbers && chapterNumbers.length > 0\"\n          class=\"no-results\">\n          No verses found for Chapter {{ selectedChapterNumber }} in {{ selectedVersionCode }}.\n        </p>\n      </div>\n      <div v-else-if=\"!isLoadingChapters && !isErrorChapters && chapterNumbers && chapterNumbers.length > 0\">\n        <p class=\"no-results\">Select a chapter.</p>\n      </div>\n\n    </main>\n\n    <!-- Fallback messages -->\n    <div v-else-if=\"!isLoadingBook && !isErrorBook && !bookDetails\">\n      <p class=\"no-results\">Could not load book details.</p>\n    </div>\n    <div v-else-if=\"!isLoadingVersions && !isErrorVersions && !selectedVersionId && versions && versions.length > 0\">\n      <p class=\"no-results\">Please select a Bible version.</p>\n    </div>\n    <div\n      v-else-if=\"bookDetails && selectedVersionCode && chapterNumbers === undefined && !isLoadingChapters && !isErrorChapters\">\n      <p class=\"no-results\">Could not load chapter list.</p>\n    </div>\n\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, watch, type Ref } from 'vue';\nimport { useDelayedTrueState } from '@/composables/useDelayedState';\nimport {\n  useBookDetails,\n  useBibleVersions,\n  useChapterNumbers, // Changed from useChapters\n  useVerseText,\n  useCatechismLinksForVerses,\n} from '@/composables/useBibleData';\nimport BaseLoadingIndicator from '@/components/BaseLoadingIndicator.vue';\nimport BaseErrorMessage from '@/components/BaseErrorMessage.vue';\nimport type { Version, Verse, BaseVerse } from '@/types'; // Use updated types\n\ninterface Props {\n  bookSlug: string;\n}\nconst props = defineProps<Props>();\n\nconst bookSlugRef = computed(() => props.bookSlug);\n\n// --- Local State Refs ---\nconst selectedVersionId = ref<number | null>(null); // Use version.id\nconst selectedChapterNumber = ref<number | null>(null); // Chapter number directly\n\n// --- Composables (Vue Query) ---\n\n// 1. Fetch Book Details -> provides id, title, cleaned_book_label\nconst {\n  data: bookDetails, // Now holds { book_id, title, cleaned_book_label }\n  isLoading: isLoadingBook,\n  isError: isErrorBook,\n  error: errorBook\n} = useBookDetails(bookSlugRef as Ref<string | undefined>);\n\n// Computed properties based on bookDetails\nconst bookId = computed(() => bookDetails.value?.book_id ?? null);\nconst bookLabel = computed(() => bookDetails.value?.cleaned_book_label ?? null); // Needed for paths\n\n// 2. Fetch Available Versions\nconst {\n  data: versions,\n  isLoading: isLoadingVersions,\n  isError: isErrorVersions,\n  error: errorVersions\n} = useBibleVersions(); // Returns Version[] with id\n\n// Computed property for selected version code (needed for paths)\nconst selectedVersionCode = computed(() => {\n  if (!selectedVersionId.value || !versions.value) return null;\n  return versions.value.find(v => v.id === selectedVersionId.value)?.abbr ?? null;\n});\n\n// 3. Fetch Chapter Numbers (NEW)\nconst {\n  data: chapterNumbers, // Returns number[] | undefined\n  isLoading: isLoadingChapters,\n  isError: isErrorChapters,\n  error: errorChapters\n} = useChapterNumbers(bookId, bookLabel, selectedVersionCode); // Pass required refs\n\n// 4a. Fetch Base Verse Text (NEW)\nconst {\n  data: baseVerses, // Returns BaseVerse[] | undefined\n  isLoading: isLoadingVerseTextRaw,\n  isError: isErrorVerseText,\n  error: errorVerseText,\n} = useVerseText(bookLabel, selectedChapterNumber, selectedVersionCode); // Pass required refs\n\n// 4b. Extract Verse IDs (use verse.id)\nconst verseIdsForLinks = computed(() => baseVerses.value?.map(v => v.id));\n\n// 4c. Fetch CCC Links (uses verse.id)\nconst {\n  data: cccLinksMap, // Returns Map<number, number[]> | undefined\n  isLoading: isLoadingCccLinksRaw,\n  isError: isErrorCccLinks,\n  error: errorCccLinks,\n} = useCatechismLinksForVerses(verseIdsForLinks);\n\n\n// --- Combined Loading/Error/Data State ---\n\nconst isLoadingVersesCombined = computed(() => {\n  // Considered loading if verse text is loading OR if links are expected and loading\n  const linksShouldLoad = !!verseIdsForLinks.value && verseIdsForLinks.value.length > 0;\n  return isLoadingVerseTextRaw.value || (linksShouldLoad && isLoadingCccLinksRaw.value);\n});\n// Apply delay only to the combined loading state for verses\nconst isLoadingVersesCombinedDelayed = useDelayedTrueState(isLoadingVersesCombined, 600);\n\n\nconst combinedVerseError = computed(() => {\n  // Prioritize errors: Book -> Version -> Chapter -> Verse Text -> CCC Links\n  if (isErrorBook.value) return `Book Error: ${errorBook.value?.message}`;\n  if (isErrorVersions.value) return `Version Error: ${errorVersions.value?.message}`;\n  if (isErrorChapters.value) return `Chapter Error: ${errorChapters.value?.message}`;\n  if (isErrorVerseText.value) return `Verse Error: ${errorVerseText.value?.message}`;\n  if (isErrorCccLinks.value) return `Link Error: ${errorCccLinks.value?.message}`;\n  return null;\n});\n\n// 4d. Merge Base Verses and Links\nconst versesWithLinks = computed((): Verse[] => {\n  if (!baseVerses.value) return [];\n  const linkMap = cccLinksMap.value; // Get map once\n  return baseVerses.value.map(baseVerse => {\n    const linkedIds = linkMap?.get(baseVerse.id); // Use baseVerse.id\n    return {\n      ...baseVerse,\n      // Use cccParagraphNumbers to match type definition\n      ...(linkedIds && linkedIds.length > 0 && { cccParagraphNumbers: linkedIds }),\n    };\n  });\n});\n\n// --- Watchers and Logic ---\n\n// Set default version (ID 1) or first available\nwatch(versions, (newVersions) => {\n  if (newVersions && newVersions.length > 0 && selectedVersionId.value === null) {\n    // Prioritize version with id=1, otherwise take the first one\n    const defaultVersion = newVersions.find(v => v.id === 1) || newVersions[0];\n    selectedVersionId.value = defaultVersion.id;\n    console.debug(`[Watcher versions] Auto-selected version ID: ${selectedVersionId.value}`);\n  }\n}, { immediate: true });\n\n// Set initial chapter when chapter numbers load\nwatch(chapterNumbers, (newChapters) => {\n  if (newChapters && newChapters.length > 0 && selectedChapterNumber.value === null) {\n    // Select the first chapter number from the list\n    selectedChapterNumber.value = newChapters[0];\n    console.debug(`[Watcher chapterNumbers] Auto-selected chapter: ${selectedChapterNumber.value}`);\n  }\n  // Reset if chapter list becomes empty/invalid while a chapter was selected\n  else if ((!newChapters || newChapters.length === 0) && selectedChapterNumber.value !== null) {\n    console.debug(\"[Watcher chapterNumbers] Chapter list empty/invalid, resetting selection.\");\n    selectedChapterNumber.value = null;\n  }\n}, { immediate: true });\n\n// Reset chapter selection if book or version changes\nwatch([bookId, selectedVersionId], () => {\n  console.debug(\"[Watcher book/version] Resetting chapter selection.\");\n  selectedChapterNumber.value = null; // Reset chapter, which will trigger re-fetch or auto-select\n});\n\n// Optional: Add logging for debugging state changes\nwatch(selectedChapterNumber, (newVal) => console.log(`Selected Chapter Number: ${newVal}`));\nwatch(selectedVersionId, (newVal) => console.log(`Selected Version ID: ${newVal}`));\nwatch(versesWithLinks, (newVal) => {\n  console.log(`%c[Verse Watcher] Merged versesWithLinks updated (${newVal?.length ?? 0} items)`, 'color: green; font-weight: bold;');\n}, { deep: true });\n\n\n// --- Methods ---\nconst showCatechismLinks = (paragraphNumbers: number[] | undefined) => {\n  if (!paragraphNumbers) return;\n  alert(`Linked Catechism Paragraphs (Numbers):\\n${paragraphNumbers.join('\\n')}`);\n};\n\nconst changeChapter = (direction: 1 | -1) => {\n  if (!chapterNumbers.value || chapterNumbers.value.length === 0 || selectedChapterNumber.value === null) return;\n\n  const currentIndex = chapterNumbers.value.indexOf(selectedChapterNumber.value);\n  if (currentIndex === -1) {\n    console.warn(\"Current chapter not found in list, cannot navigate.\");\n    return; // Should not happen if state is consistent\n  }\n\n  const newIndex = currentIndex + direction;\n  if (newIndex >= 0 && newIndex < chapterNumbers.value.length) {\n    selectedChapterNumber.value = chapterNumbers.value[newIndex];\n    console.debug(`Changed chapter to: ${selectedChapterNumber.value}`);\n  }\n};\n\n</script>\n\n<style scoped>\n/* Styles remain largely the same, adjust if needed */\n.book-detail-view {\n  padding-top: var(--spacing-lg);\n  padding-bottom: var(--spacing-lg);\n}\n\n.book-header {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--spacing-sm);\n}\n\n.book-header h1 {\n  margin-bottom: var(--spacing-xs);\n}\n\n.version-selector {\n  font-size: 0.95em;\n  color: var(--text-secondary);\n}\n\n.version-selector label {\n  margin-right: var(--spacing-xs);\n}\n\n.version-selector select {\n  padding: var(--spacing-xs) var(--spacing-sm);\n  border-radius: var(--radius-sm);\n  border: 1px solid var(--border-primary);\n  background-color: var(--bg-primary);\n  color: var(--text-primary);\n  min-width: 150px;\n}\n\n.single-version {\n  font-size: 0.95em;\n  color: var(--text-secondary);\n  margin: 0;\n}\n\nmain {\n  margin-top: var(--spacing-lg);\n}\n\n.chapter-nav {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: var(--spacing-sm) 0;\n  margin-bottom: var(--spacing-lg);\n  border-bottom: 1px solid var(--border-divider);\n  border-top: 1px solid var(--border-divider);\n}\n\n.chapter-nav span {\n  font-weight: 600;\n  color: var(--text-heading);\n  flex-grow: 1;\n  text-align: center;\n  margin: 0 var(--spacing-sm);\n}\n\n.chapter-nav button {\n  padding: var(--spacing-xs) var(--spacing-md);\n  border: 1px solid var(--border-primary);\n  background-color: var(--bg-secondary);\n  color: var(--text-link);\n  border-radius: var(--radius-sm);\n  cursor: pointer;\n  transition: background-color var(--transition-fast);\n}\n\n.chapter-nav button:hover:not(:disabled) {\n  background-color: var(--bg-tertiary);\n  border-color: var(--border-hover);\n}\n\n.chapter-nav button:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.single-chapter-heading {\n  text-align: center;\n  margin-bottom: var(--spacing-lg);\n  font-weight: 500;\n  font-size: 1.2rem;\n  color: var(--text-secondary);\n}\n\n.content-area {\n  margin-top: var(--spacing-lg);\n  min-height: 200px;\n  /* Give space for loading indicator */\n  position: relative;\n  /* Needed for absolute positioning of loader if desired */\n}\n\n.verses-container {\n  line-height: 1.8;\n  padding: 0 var(--spacing-sm);\n}\n\n.verse {\n  margin-bottom: var(--spacing-md);\n}\n\n.verse sup {\n  font-weight: bold;\n  margin-right: 0.6em;\n  color: var(--text-link);\n  font-size: 0.8em;\n  line-height: 1;\n  vertical-align: super;\n}\n\n.no-results {\n  text-align: center;\n  color: var(--text-secondary);\n  margin-top: var(--spacing-xl);\n  font-style: italic;\n}\n\n.ccc-link-indicator {\n  margin-left: 8px;\n  color: var(--text-link);\n  cursor: pointer;\n  font-size: 0.8em;\n  font-weight: bold;\n  user-select: none;\n  /* Prevent text selection */\n  display: inline-block;\n  /* Allows transform */\n  transition: transform 0.1s ease-out;\n}\n\n.ccc-link-indicator:hover {\n  text-decoration: underline;\n  transform: scale(1.1);\n}\n\n.ccc-link-indicator:focus {\n  outline: 1px dotted var(--text-link);\n  outline-offset: 2px;\n  border-radius: 2px;\n}\n\n/* Center loading indicator within content area */\n.content-area .loading-indicator {\n  /* position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%); */\n  margin-top: var(--spacing-xl);\n  /* Simpler margin approach */\n}\n</style>",
    "GenreDetailView.vue": "//src/views/GenreDetailView.vue\n\n<template>\n  <div class=\"genre-detail-view container\">\n    <header class=\"view-header\">\n      <BaseLoadingIndicator v-if=\"isLoadingGenre\" message=\"Loading genre details...\" />\n      <BaseErrorMessage v-if=\"isErrorGenre\" :message=\"errorGenre?.message\" />\n      <h1 v-if=\"!isLoadingGenre && !isErrorGenre && genreName\">{{ genreName }}</h1>\n      <h1 v-if=\"!isLoadingGenre && !isErrorGenre && !genreName && !isLoadingGenre\">Genre Not Found</h1>\n    </header>\n\n    <main>\n      <BaseLoadingIndicator v-if=\"isLoadingBooks\" message=\"Loading books...\" />\n      <BaseErrorMessage v-if=\"isErrorBooks\" :message=\"errorBooks?.message\" />\n\n      <div v-if=\"!isLoadingBooks && !isErrorBooks && books && books.length > 0\" class=\"book-list\">\n        <router-link v-for=\"book in books\" :key=\"book.book_id\" :to=\"{\n          name: 'book-detail',\n          params: {\n            testamentSlug: props.testamentSlug,\n            genreSlug: props.genreSlug,\n            bookSlug: book.slug\n          },\n        }\" class=\"book-link list-item-link\" v-prefetch=\"createBookPrefetchOptions(book.slug)\">\n          {{ book.title }}\n        </router-link>\n      </div>\n\n      <p v-if=\"!isLoadingBooks && !isErrorBooks && books && books.length === 0\" class=\"no-results\">\n        No books found listed under this genre ({{ genreName }}).\n      </p>\n    </main>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, type Ref, watch } from 'vue';\nimport { useGenreDetails, useBooksByGenre } from '@/composables/useBibleData';\nimport { createBookPrefetchOptions } from '@/utils/prefetchHelpers';\nimport BaseLoadingIndicator from '@/components/BaseLoadingIndicator.vue';\nimport BaseErrorMessage from '@/components/BaseErrorMessage.vue';\n\ninterface Props {\n  testamentSlug: string;\n  genreSlug: string;\n}\nconst props = defineProps<Props>();\n\nconsole.log(`[GenreDetailView] Rendering with genreSlug: ${props.genreSlug}`);\n\nconst genreSlugRef = computed(() => props.genreSlug);\n\n// Fetch Genre Details\nconst {\n  data: genreDetailsData,\n  isLoading: isLoadingGenre,\n  isError: isErrorGenre,\n  error: errorGenre,\n  status: genreStatus\n} = useGenreDetails(genreSlugRef as Ref<string | undefined>);\n\n// Log genre details query results reactively\nwatch(genreStatus, (newStatus) => {\n  console.log(`[GenreDetailView] Genre Details Status: ${newStatus}`);\n  if (newStatus === 'success') {\n    console.log(`[GenreDetailView] Genre Details Data:`, genreDetailsData.value);\n  }\n  if (newStatus === 'error') {\n    console.error(`[GenreDetailView] Genre Details Error:`, errorGenre.value?.message);\n  }\n});\n\n// Recreate computed properties for genre name and ID\nconst genreName = computed(() => genreDetailsData.value?.name ?? '');\nconst genreId = computed(() => genreDetailsData.value?.genre_id ?? null);\n\n// Fetch Books based on the computed genreId ref\nconst {\n  data: books,\n  isLoading: isLoadingBooks,\n  isError: isErrorBooks,\n  error: errorBooks,\n  status: booksStatus,\n  isFetching: isFetchingBooks\n} = useBooksByGenre(genreId);\n\n// Log the enabled state for the books query directly\nconst isBooksQueryEnabled = computed(() => typeof genreId.value === 'number');\nwatch(isBooksQueryEnabled, (enabled) => {\n  console.log(`%c[GenreDetailView] Is Books Query Enabled?: ${enabled}`, 'color: red; font-weight: bold;');\n}, { immediate: true });\n</script>\n\n<style scoped>\n.genre-detail-view {\n  padding-top: var(--spacing-lg);\n  padding-bottom: var(--spacing-lg);\n}\n\nmain {\n  margin-top: var(--spacing-lg);\n}\n\n.book-list {\n  margin-top: var(--spacing-md);\n}\n\n.no-results {\n  text-align: center;\n  color: var(--text-secondary);\n  margin-top: var(--spacing-xl);\n  font-style: italic;\n}\n</style>",
    "HomeView.vue": "<template>\n  <div class=\"home-view container\">\n    <h1>Testaments de la Bible</h1>\n\n    <BaseLoadingIndicator v-if=\"isLoading\" message=\"Loading testaments...\" />\n    <BaseErrorMessage v-if=\"isError\" :message=\"error?.message\" />\n\n    <section v-if=\"!isLoading && !isError && testaments && testaments.length > 0\" class=\"testament-sections\">\n      <router-link v-for=\"testament in testaments\" :key=\"testament.testament_id\"\n        :to=\"{ name: 'testament-detail', params: { testamentSlug: testament.slug } }\" custom v-slot=\"{ navigate }\">\n        <div class=\"testament-section card\" role=\"link\" tabindex=\"0\" @click=\"navigate\" @keydown.enter=\"navigate\"\n          @keydown.space.prevent=\"navigate\" v-prefetch=\"{\n            queryKey: ['testament_detail', testament.slug],\n            queryFn: () => fetchTestamentBySlug(testament.slug),\n            staleTime: 60 * 1000\n          }\">\n          <h2>{{ testament.name }}</h2>\n        </div>\n      </router-link>\n    </section>\n\n    <p v-if=\"!isLoading && !isError && testaments && testaments.length === 0\" class=\"no-results\">\n      No testaments found in the database for the selected language.\n    </p>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { useTestaments } from '@/composables/useBibleData';\nimport { fetchTestamentBySlug } from '@/services/apiService';\nimport BaseLoadingIndicator from '@/components/BaseLoadingIndicator.vue';\nimport BaseErrorMessage from '@/components/BaseErrorMessage.vue';\n\n// useQuery returns specific properties\nconst {\n  data: testaments, // Access data via the 'data' ref\n  isLoading,       // True during initial fetch when no data is cached yet\n  isError,         // Boolean flag for error state\n  error            // The actual error object (Ref<Error | null>)\n  // isFetching,    // True during initial fetch AND background refetches (optional)\n} = useTestaments();\n\n</script>\n\n<style scoped>\n.home-view {\n  padding-top: var(--spacing-xl);\n  padding-bottom: var(--spacing-xl);\n}\n\nh1 {\n  margin-bottom: var(--spacing-xl);\n}\n\n.testament-sections {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n  gap: var(--spacing-lg);\n  margin-top: var(--spacing-lg);\n}\n\n.testament-section {\n  padding: var(--spacing-xl);\n  text-align: center;\n  cursor: pointer;\n}\n\n.testament-section:focus {\n  outline: 2px solid var(--text-link);\n  outline-offset: 2px;\n}\n\n.testament-section h2 {\n  margin: 0;\n  color: var(--text-heading);\n  font-size: 1.4rem;\n}\n\n.no-results {\n  text-align: center;\n  color: var(--text-secondary);\n  margin-top: var(--spacing-xl);\n  font-style: italic;\n}\n</style>",
    "NotFoundView.vue": "<template>\n    <div class=\"not-found-view container\">\n        <h1>404 - Page Not Found</h1>\n        <p>Sorry, the page you are looking for does not exist.</p>\n        <router-link :to=\"{ name: 'home' }\">Go to Home</router-link>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n// No script logic needed for a simple not found page\n</script>\n\n<style scoped>\n.not-found-view {\n    text-align: center;\n    padding: var(--spacing-xl) var(--spacing-lg);\n}\n\n.not-found-view h1 {\n    color: var(--error-text);\n    margin-bottom: var(--spacing-md);\n}\n\n.not-found-view p {\n    color: var(--text-secondary);\n    margin-bottom: var(--spacing-lg);\n}\n</style>",
    "TestamentView.vue": "<template>\n  <div class=\"testament-view container\">\n    <header class=\"view-header\">\n      <BaseLoadingIndicator v-if=\"isLoading\" message=\"Loading Testament...\" />\n      <BaseErrorMessage v-if=\"isError\" :message=\"error?.message\" />\n      <h1 v-if=\"!isLoading && !isError && testamentName\">{{ testamentName }}</h1>\n      <h1 v-if=\"!isLoading && !isError && !testamentName\">Testament Not Found</h1>\n    </header>\n\n    <main>\n      <TestamentGenreList v-if=\"!isLoading && !isError && testamentId && props.testamentSlug\"\n        :testament-id=\"testamentId\" :testament-slug=\"props.testamentSlug\" />\n      <p v-if=\"!isLoading && !isError && !testamentId\" class=\"no-results\">\n        Could not load details for this testament.\n      </p>\n    </main>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, type Ref } from 'vue';\n// No longer need useRoute if slug comes from props\nimport { useTestamentDetails } from '@/composables/useBibleData';\nimport TestamentGenreList from '@/components/TestamentGenreList.vue';\nimport BaseLoadingIndicator from '@/components/BaseLoadingIndicator.vue';\nimport BaseErrorMessage from '@/components/BaseErrorMessage.vue';\n\ninterface Props {\n  testamentSlug: string;\n}\nconst props = defineProps<Props>();\n\n// Use computed for reactive prop access passed to useQuery key\nconst slugRef = computed(() => props.testamentSlug);\n\n// Get Vue Query result object\nconst {\n  data: testamentDetails, // The raw data object { name, testament_id } | null\n  isLoading,\n  isError,\n  error\n} = useTestamentDetails(slugRef as Ref<string | undefined>); // Cast needed if prop isn't optional\n\n// Recreate computed properties based on the data returned by useQuery\nconst testamentName = computed(() => testamentDetails.value?.name ?? '');\nconst testamentId = computed(() => testamentDetails.value?.testament_id ?? null);\n\n</script>\n\n<style scoped>\n.testament-view {\n  padding-top: var(--spacing-lg);\n  padding-bottom: var(--spacing-lg);\n}\n\nmain {\n  margin-top: var(--spacing-lg);\n}\n\n.no-results {\n  text-align: center;\n  color: var(--text-secondary);\n  margin-top: var(--spacing-xl);\n  font-style: italic;\n}\n</style>"
  }
}