{
  "App.vue": "<template>\n    <div id=\"app-wrapper\">\n        <header class=\"app-header\">\n            <nav>\n                <router-link :to=\"{ name: 'home' }\">Home</router-link>\n            </nav>\n            <div class=\"auth-section\">\n                <BaseLoadingIndicator v-if=\"isAuthLoading\" message=\"Auth...\" />\n                <BaseErrorMessage :message=\"authError\" />\n                <span v-if=\"isLoggedIn && user\">Welcome, {{ user.email }}!</span>\n                <button v-if=\"isLoggedIn\" @click=\"handleSignOut\">Sign Out</button>\n            </div>\n        </header>\n\n        <main class=\"app-main\">\n            <router-view v-slot=\"{ Component, route }\">\n                <component :is=\"Component\" :key=\"route.path\" />\n            </router-view>\n        </main>\n\n        <footer class=\"app-footer\">\n            <p>© {{ new Date().getFullYear() }} Bible App</p>\n        </footer>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { useSupabaseAuth } from '@/composables/useSupabaseAuth';\nimport BaseLoadingIndicator from '@/components/BaseLoadingIndicator.vue';\nimport BaseErrorMessage from '@/components/BaseErrorMessage.vue';\nimport { useRouter } from 'vue-router';\n\nconst router = useRouter();\nconst {\n    user,\n    isLoggedIn,\n    isLoading: isAuthLoading, // Renamed to avoid conflict if other loading states exist\n    error: authError,\n    signOut\n} = useSupabaseAuth();\n\nconst handleSignOut = async () => {\n    const { success } = await signOut();\n    if (success) {\n        // Optionally navigate the user after sign out\n        router.push({ name: 'home' });\n        console.log('User signed out successfully.');\n    } else {\n        // Error is handled and displayed by the auth store/composable\n        console.error('Sign out failed.');\n    }\n};\n\n// Global error handling example (optional)\n// import { onErrorCaptured } from 'vue';\n// onErrorCaptured((err, instance, info) => {\n//   console.error(\"Unhandled error captured in App.vue:\", err, info);\n//   // Send to logging service (Sentry, etc.)\n//   // Display a generic error message to the user\n//   // globalError.value = 'An unexpected error occurred.';\n//   return false; // Prevent propagation if handled\n// });\n\n</script>\n\n<style scoped>\n#app-wrapper {\n    display: flex;\n    flex-direction: column;\n    min-height: 100vh;\n    background-color: var(--bg-primary);\n}\n\n.app-header {\n    padding: var(--spacing-sm) var(--spacing-lg);\n    background-color: var(--bg-secondary);\n    border-bottom: 1px solid var(--border-divider);\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: var(--spacing-md);\n}\n\n.app-header nav {\n    display: flex;\n    gap: var(--spacing-md);\n}\n\n.app-header nav a {\n    color: var(--text-link);\n    text-decoration: none;\n    font-weight: 500;\n}\n\n.app-header nav a:hover,\n.app-header nav a.router-link-exact-active {\n    color: var(--text-link-hover);\n    text-decoration: underline;\n}\n\n.auth-section {\n    display: flex;\n    align-items: center;\n    gap: var(--spacing-sm);\n    font-size: 0.9rem;\n    color: var(--text-secondary);\n}\n\n.auth-section button {\n    padding: var(--spacing-xs) var(--spacing-sm);\n    font-size: 0.85rem;\n    border: 1px solid var(--border-primary);\n    background-color: var(--bg-primary);\n    color: var(--text-primary);\n    border-radius: var(--radius-sm);\n    cursor: pointer;\n}\n\n.auth-section button:hover {\n    background-color: var(--bg-tertiary);\n}\n\n.auth-section .loading-indicator,\n.auth-section .error-message-box {\n    padding: var(--spacing-xs);\n    margin: 0;\n    font-size: 0.8rem;\n    border: none;\n    background: none;\n}\n\n.auth-section .loading-indicator .spinner {\n    width: 16px;\n    height: 16px;\n    border-width: 2px;\n}\n\n\n.app-main {\n    flex-grow: 1;\n}\n\n.app-footer {\n    padding: var(--spacing-md) var(--spacing-lg);\n    text-align: center;\n    font-size: 0.85rem;\n    color: var(--text-secondary);\n    border-top: 1px solid var(--border-divider);\n    background-color: var(--bg-secondary);\n    margin-top: auto;\n}\n\n.app-footer p {\n    margin: 0;\n}\n</style>",
  "api": {},
  "assets": {
    "main.css": "/* Keep only the light theme variables */\n:root {\n  --bg-primary: #ffffff;\n  --bg-secondary: #f8fafd;\n  --bg-tertiary: #f1f5f9; /* Slightly adjusted tertiary */\n  --text-primary: #2c3e50;\n  --text-secondary: #64748b; /* Adjusted secondary text */\n  --text-heading: #1e293b; /* Darker heading */\n  --text-link: #3b82f6; /* Brighter blue link */\n  --text-link-hover: #2563eb; /* Darker blue hover */\n  --border-primary: #e2e8f0; /* Lighter border */\n  --border-secondary: #cbd5e1;\n  --border-hover: #94a3b8; /* Greyish hover border */\n  --border-divider: #f1f5f9; /* Very light divider */\n  --error-bg: #fee2e2; /* Lighter error bg */\n  --error-text: #b91c1c; /* Darker error text */\n  --error-border: #fecaca; /* Lighter error border */\n  --shadow-color-light: rgba(0, 0, 0, 0.05);\n  --shadow-color-medium: rgba(0, 0, 0, 0.1);\n\n  --spacing-xs: 4px; /* Adjusted spacing scale slightly */\n  --spacing-sm: 8px;\n  --spacing-md: 16px;\n  --spacing-lg: 24px;\n  --spacing-xl: 32px;\n  --radius-sm: 4px;\n  --radius-md: 6px;\n  --radius-lg: 8px;\n\n  --transition-fast: 0.15s ease-in-out;\n  --transition-std: 0.2s ease-in-out;\n}\n\n/* --- Global Resets & Base Styles --- */\n\n*,\n*::before,\n*::after {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n\nhtml {\n  font-size: 16px;\n  scroll-behavior: smooth; /* Smooth scrolling for anchors */\n}\n\nbody {\n  font-family:\n    Inter,\n    -apple-system,\n    BlinkMacSystemFont,\n    'Segoe UI',\n    Roboto,\n    Helvetica,\n    Arial,\n    sans-serif,\n    'Apple Color Emoji',\n    'Segoe UI Emoji'; /* Modern font stack */\n  background-color: var(--bg-primary);\n  color: var(--text-primary);\n  line-height: 1.6;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  transition:\n    background-color var(--transition-std),\n    color var(--transition-std);\n}\n\na {\n  color: var(--text-link);\n  text-decoration: none;\n  transition: color var(--transition-fast);\n}\n\na:hover {\n  color: var(--text-link-hover);\n  text-decoration: underline;\n}\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  text-align: center;\n  color: var(--text-heading);\n  margin-bottom: var(--spacing-md);\n  line-height: 1.3;\n  font-weight: 600;\n}\n\nh1 {\n  font-size: 2rem;\n}\nh2 {\n  font-size: 1.5rem;\n}\nh3 {\n  font-size: 1.25rem;\n}\n/* Add h4, h5, h6 if needed */\n\np {\n  margin-bottom: var(--spacing-md);\n}\n\n/* --- Layout & Utility Classes --- */\n\n.container {\n  max-width: 960px; /* Slightly wider container */\n  margin-left: auto;\n  margin-right: auto;\n  padding-left: var(--spacing-lg);\n  padding-right: var(--spacing-lg);\n  width: 100%;\n}\n\n/* Reusable loading/error text styles (used by base components) */\n.loading-indicator p, /* Target the p inside the component */\n.error-message-box p {\n  /* Target the p inside the component */\n  margin: 0; /* Remove default paragraph margin */\n}\n\n/* Card Style */\n.card {\n  border: 1px solid var(--border-primary);\n  padding: var(--spacing-lg);\n  border-radius: var(--radius-lg);\n  background-color: var(--bg-primary); /* Use primary bg for cards */\n  box-shadow:\n    0 1px 3px var(--shadow-color-light),\n    0 1px 2px var(--shadow-color-light); /* Subtle shadow */\n  transition:\n    box-shadow var(--transition-std),\n    transform var(--transition-std);\n}\n\n.card:hover {\n  box-shadow:\n    0 4px 6px var(--shadow-color-light),\n    0 1px 3px var(--shadow-color-medium); /* Slightly stronger hover shadow */\n  transform: translateY(-2px);\n}\n\n/* List Item Link Style */\n.list-item-link {\n  display: block;\n  text-decoration: none;\n  color: var(--text-primary);\n  background-color: var(--bg-secondary); /* Use secondary for list items */\n  border: 1px solid var(--border-primary);\n  padding: var(--spacing-sm) var(--spacing-md);\n  margin-bottom: var(--spacing-sm);\n  border-radius: var(--radius-md);\n  transition:\n    background-color var(--transition-std),\n    border-color var(--transition-std),\n    transform var(--transition-fast),\n    box-shadow var(--transition-std);\n  box-shadow: 0 1px 2px var(--shadow-color-light);\n}\n\n.list-item-link:hover,\n.list-item-link:focus {\n  background-color: var(--bg-tertiary); /* Use tertiary for hover */\n  border-color: var(--border-secondary);\n  transform: translateY(-1px);\n  box-shadow: 0 2px 4px var(--shadow-color-light);\n  outline: none;\n  color: var(--text-link); /* Highlight text on hover */\n}\n\n.list-item-link:last-child {\n  margin-bottom: 0;\n}\n\n/* Divider */\n.divider {\n  border: 0;\n  height: 1px;\n  background-color: var(--border-divider);\n  margin: var(--spacing-lg) 0;\n}\n\n/* View Header Style */\n.view-header {\n  margin-bottom: var(--spacing-lg);\n  padding-bottom: var(--spacing-md); /* Adjusted padding */\n  border-bottom: 1px solid var(--border-divider);\n  text-align: center; /* Center header content by default */\n}\n.view-header h1,\n.view-header h2 {\n  margin-bottom: 0; /* Remove bottom margin within header */\n}\n\n/* Add other global styles or utility classes as needed */\n"
  },
  "components": {
    "BaseErrorMessage.vue": "<template>\n    <div v-if=\"message\" class=\"error-message-box\" role=\"alert\">\n        <p><strong>Error:</strong> {{ message }}</p>\n        <!-- Optionally add an icon or close button -->\n    </div>\n</template>\n\n<script setup lang=\"ts\">\ninterface Props {\n    message: string | null | undefined;\n}\n\ndefineProps<Props>();\n</script>\n\n<style scoped>\n.error-message-box {\n    color: var(--error-text);\n    background-color: var(--error-bg);\n    border: 1px solid var(--error-border);\n    padding: var(--spacing-md);\n    border-radius: var(--radius-sm);\n    margin: var(--spacing-lg) 0;\n    text-align: center;\n}\n\n.error-message-box p {\n    margin: 0;\n}\n</style>",
    "BaseLoadingIndicator.vue": "<template>\n    <div class=\"loading-indicator\" role=\"status\" aria-live=\"polite\">\n        <p>{{ message }}</p>\n        <!-- Add a spinner or animation here if desired -->\n        <div class=\"spinner\"></div>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\ninterface Props {\n    message?: string;\n}\n\nwithDefaults(defineProps<Props>(), {\n    message: 'Loading...',\n});\n</script>\n\n<style scoped>\n.loading-indicator {\n    text-align: center;\n    color: var(--text-secondary);\n    padding: var(--spacing-xl) var(--spacing-md);\n    font-style: italic;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    gap: var(--spacing-sm);\n}\n\n/* Basic Spinner Example */\n.spinner {\n    border: 4px solid var(--bg-secondary);\n    border-top: 4px solid var(--text-link);\n    border-radius: 50%;\n    width: 30px;\n    height: 30px;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% {\n        transform: rotate(0deg);\n    }\n\n    100% {\n        transform: rotate(360deg);\n    }\n}\n</style>",
    "TestamentGenreList.vue": "<template>\n  <div class=\"testament-genre-list\">\n    <BaseLoadingIndicator v-if=\"isLoading\" message=\"Loading genres...\" />\n    <BaseErrorMessage :message=\"error\" />\n\n    <div v-if=\"!isLoading && !error && genres.length > 0\">\n      <div v-if=\"!isLoading && !error && genres.length > 0\">\n        <router-link v-for=\"genre in genres\" :key=\"genre.genre_id\" :to=\"{\n          name: 'genre-detail',\n          params: { testamentSlug: props.testamentSlug, genreSlug: genre.slug },\n        }\" class=\"genre-link list-item-link\" v-prefetch=\"{\n          queryKey: ['genre_detail', genre.slug],\n          queryFn: () => fetchGenreBySlug(genre.slug),\n          staleTime: 60 * 1000\n        }\">\n          {{ genre.name }}\n        </router-link>\n      </div>\n\n      <p v-if=\"!isLoading && !error && genres.length === 0\" class=\"no-results\">\n        No specific genres found listed under this testament.\n      </p>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { toRef } from 'vue';\nimport { useTestamentGenres } from '@/composables/useBibleData';\nimport { fetchGenreBySlug } from '@/services/apiService';\nimport BaseLoadingIndicator from '@/components/BaseLoadingIndicator.vue';\nimport BaseErrorMessage from '@/components/BaseErrorMessage.vue';\n\ninterface Props {\n  testamentId: number | null; // Allow null initially\n  testamentSlug: string; // Needed for linking\n}\n\nconst props = defineProps<Props>();\nconst testamentIdRef = toRef(props, 'testamentId');\nconst { data: genres, isLoading, error } = useTestamentGenres(testamentIdRef);\n\n</script>\n\n<style scoped>\n.testament-genre-list {\n  padding-top: var(--spacing-lg);\n}\n\n.no-results {\n  text-align: center;\n  color: var(--text-secondary);\n  margin-top: var(--spacing-lg);\n  font-style: italic;\n}\n</style>"
  },
  "composables": {
    "useBibleData.ts": "/**\n * @file Composable functions for fetching and managing Bible-related data state using Vue Query.\n */\nimport { type Ref, computed } from 'vue'\nimport { useQuery } from '@tanstack/vue-query'\nimport * as apiService from '@/services/apiService'\nimport type {\n  TestamentTranslation,\n  GenreTranslation,\n  BookSummary,\n  Chapter,\n  Version,\n  Verse,\n} from '@/types'\n\n/**\n * Fetches and manages the list of testaments.\n * @returns Vue Query result object for testaments.\n */\nexport function useTestaments() {\n  return useQuery({\n    queryKey: ['testaments'], // Unique key for this query\n    queryFn: apiService.fetchTestaments, // The function that fetches data\n    // staleTime is likely set globally in main.ts, but can override here\n    // staleTime: 5 * 60 * 1000,\n  })\n  // Returns { data, isLoading, isFetching, isError, error, refetch, status, ... }\n}\n\n/**\n * Fetches and manages details for a specific testament based on its slug.\n * @param testamentSlugRef - A Ref containing the testament slug.\n * @returns Vue Query result object for testament details.\n */\nexport function useTestamentDetails(testamentSlugRef: Ref<string | undefined>) {\n  return useQuery({\n    queryKey: ['testament_detail', testamentSlugRef], // Key includes dependency\n    queryFn: () => {\n      const slug = testamentSlugRef.value\n      if (!slug) {\n        // Returning undefined or null usually prevents the queryFn from running if enabled is false\n        // Or throw to indicate an invalid state if enabled is true\n        throw new Error('Testament slug is required but missing.')\n        // return Promise.resolve(null); // Or return null/empty if preferred when disabled\n      }\n      return apiService.fetchTestamentBySlug(slug)\n    },\n    // Only run the query if the slug exists\n    enabled: computed(() => !!testamentSlugRef.value),\n  })\n}\n\n/**\n * Fetches and manages the list of book genres for a given testament ID.\n * @param testamentIdRef - A Ref containing the testament ID.\n * @returns Vue Query result object for testament genres.\n */\nexport function useTestamentGenres(testamentIdRef: Ref<number | null>) {\n  return useQuery({\n    queryKey: ['testament_genres', testamentIdRef], // Key includes dependency\n    queryFn: () => {\n      const id = testamentIdRef.value\n      if (id === null) {\n        // Query function should ideally not run if ID is null due to `enabled` option\n        // Throwing here ensures error state if it runs unexpectedly\n        throw new Error('Testament ID is required but missing.')\n        // return Promise.resolve([]); // Or return empty array\n      }\n      return apiService.fetchGenresForTestament(id)\n    },\n    // Only run the query if the ID is a valid number\n    enabled: computed(() => typeof testamentIdRef.value === 'number'),\n  })\n}\n\n/**\n * Fetches and manages details for a specific genre based on its slug.\n * @param genreSlugRef - A Ref containing the genre slug.\n * @returns Vue Query result object for genre details.\n */\nexport function useGenreDetails(genreSlugRef: Ref<string | undefined>) {\n  return useQuery({\n    queryKey: ['genre_detail', genreSlugRef],\n    queryFn: () => {\n      const slug = genreSlugRef.value\n      if (!slug) {\n        throw new Error('Genre slug is required but missing.')\n      }\n      return apiService.fetchGenreBySlug(slug)\n    },\n    enabled: computed(() => !!genreSlugRef.value),\n  })\n}\n\n/**\n * Fetches and manages the list of books for a given genre ID.\n * @param genreIdRef - A Ref containing the genre ID.\n * @returns Vue Query result object for books.\n */\nexport function useBooksByGenre(genreIdRef: Ref<number | null>) {\n  return useQuery({\n    queryKey: ['books_by_genre', genreIdRef],\n    queryFn: () => {\n      const id = genreIdRef.value\n      if (id === null) {\n        throw new Error('Genre ID is required but missing.')\n      }\n      return apiService.fetchBooksByGenre(id)\n    },\n    enabled: computed(() => typeof genreIdRef.value === 'number'),\n  })\n}\n\n/**\n * Fetches and manages details for a specific book based on its slug.\n * @param bookSlugRef - A Ref containing the book slug.\n * @returns Vue Query result object for book details.\n */\nexport function useBookDetails(bookSlugRef: Ref<string | undefined>) {\n  return useQuery({\n    queryKey: ['book_detail', bookSlugRef],\n    queryFn: () => {\n      const slug = bookSlugRef.value\n      if (!slug) {\n        throw new Error('Book slug is required but missing.')\n      }\n      return apiService.fetchBookBySlug(slug)\n    },\n    enabled: computed(() => !!bookSlugRef.value),\n  })\n}\n\n/**\n * Fetches and manages the list of available Bible versions.\n * @returns Vue Query result object for versions.\n */\nexport function useBibleVersions() {\n  return useQuery({\n    queryKey: ['bible_versions'],\n    queryFn: apiService.fetchAvailableVersions,\n  })\n}\n\n/**\n * Fetches and manages the list of chapters for a given book ID.\n * @param bookIdRef - A Ref containing the book ID.\n * @returns Vue Query result object for chapters.\n */\nexport function useChapters(bookIdRef: Ref<number | null>) {\n  return useQuery({\n    queryKey: ['chapters', bookIdRef],\n    queryFn: () => {\n      const id = bookIdRef.value\n      if (id === null) {\n        throw new Error('Book ID is required but missing.')\n      }\n      return apiService.fetchChaptersForBook(id)\n    },\n    enabled: computed(() => typeof bookIdRef.value === 'number'),\n  })\n}\n\n/**\n * Fetches and manages the list of verses for a given chapter and version ID.\n * @param chapterIdRef - A Ref containing the chapter ID.\n * @param versionIdRef - A Ref containing the version ID.\n * @returns Vue Query result object for verses.\n */\nexport function useVerses(chapterIdRef: Ref<number | null>, versionIdRef: Ref<number | null>) {\n  return useQuery({\n    // Key includes both dependencies\n    queryKey: ['verses', chapterIdRef, versionIdRef],\n    queryFn: () => {\n      const chapterId = chapterIdRef.value\n      const versionId = versionIdRef.value\n      if (chapterId === null || versionId === null) {\n        throw new Error('Chapter ID and Version ID are required but missing.')\n      }\n      return apiService.fetchVersesForChapter(chapterId, versionId)\n    },\n    // Only run the query if both IDs are valid numbers\n    enabled: computed(\n      () => typeof chapterIdRef.value === 'number' && typeof versionIdRef.value === 'number',\n    ),\n  })\n}\n",
    "useDelayedState.ts": "// src/composables/useDelayedState.ts\nimport { ref, watch, type Ref, onUnmounted } from 'vue'\n\n/**\n * Creates a ref that reflects the value of a source ref but only\n * becomes true after a specified delay. Resets immediately if the source becomes false.\n * @param sourceRef The source boolean ref (e.g., isLoading).\n * @param delayMs The delay in milliseconds before the returned ref becomes true.\n * @returns A ref that is true only if the sourceRef has been true for delayMs.\n */\nexport function useDelayedTrueState(sourceRef: Ref<boolean>, delayMs: number = 600): Ref<boolean> {\n  const delayedState = ref(false)\n  let timerId: ReturnType<typeof setTimeout> | null = null\n\n  watch(\n    sourceRef,\n    (newValue) => {\n      if (newValue) {\n        // Source became true, start timer\n        if (timerId === null) {\n          // Prevent multiple timers\n          timerId = setTimeout(() => {\n            // Only set to true if source is STILL true after delay\n            if (sourceRef.value) {\n              delayedState.value = true\n            }\n            timerId = null // Timer finished\n          }, delayMs)\n        }\n      } else {\n        // Source became false, clear timer and reset state immediately\n        if (timerId !== null) {\n          clearTimeout(timerId)\n          timerId = null\n        }\n        delayedState.value = false\n      }\n    },\n    { immediate: true },\n  ) // Check initial state\n\n  // Cleanup timer on component unmount\n  onUnmounted(() => {\n    if (timerId !== null) {\n      clearTimeout(timerId)\n    }\n  })\n\n  return delayedState\n}\n",
    "useSupabaseAuth.ts": "/**\n * @file Composable to easily access the auth store state and actions.\n * Provides a cleaner interface for components compared to directly importing the store.\n */\nimport { computed } from 'vue'\nimport { useAuthStore } from '@/stores/auth.store'\nimport type {\n  SignInWithPasswordCredentials,\n  SignUpWithPasswordCredentials,\n} from '@supabase/supabase-js'\n\nexport function useSupabaseAuth() {\n  const authStore = useAuthStore()\n\n  // Expose state and getters as computed refs for reactivity\n  const user = computed(() => authStore.user)\n  const session = computed(() => authStore.session)\n  const isLoading = computed(() => authStore.isLoading)\n  const error = computed(() => authStore.error)\n  const isLoggedIn = computed(() => authStore.isLoggedIn)\n  const userId = computed(() => authStore.userId)\n\n  // Expose actions directly\n  const { init, signInWithEmail, signUpWithEmail, signOut } = authStore\n\n  return {\n    // State & Getters (as computed refs)\n    user,\n    session,\n    isLoading,\n    error,\n    isLoggedIn,\n    userId,\n\n    // Actions (as functions)\n    init,\n    signInWithEmail,\n    signUpWithEmail,\n    signOut,\n  }\n}\n"
  },
  "constants": {
    "index.ts": "/**\n * @file Application-wide constants.\n */\n\n/**\n * Default language code used throughout the application.\n * Currently set to French.\n */\nexport const DEFAULT_LANGUAGE_NAME = 'Français'\n"
  },
  "directives": {
    "prefetch.ts": "// src/directives/prefetch.ts\nimport { type Directive, inject } from 'vue'\nimport { QueryClient, VUE_QUERY_CLIENT } from '@tanstack/vue-query'\nimport type { PrefetchOptions } from '@tanstack/vue-query'\n\n// Helper to check if the value is valid (basic check)\nfunction isValidBindingValue(value: any): value is PrefetchOptions {\n  return (\n    value &&\n    typeof value === 'object' &&\n    Array.isArray(value.queryKey) &&\n    typeof value.queryFn === 'function'\n  )\n}\n\nexport const vPrefetch: Directive<HTMLElement, PrefetchOptions | undefined> = {\n  mounted(el, binding) {\n    // --- Inject Client HERE in mounted ---\n    const queryClient = inject<QueryClient>(VUE_QUERY_CLIENT)\n\n    // --- Critical Check: Ensure client was injected ---\n    if (!queryClient) {\n      console.warn(\n        'v-prefetch mounted: QueryClient not available via inject(). Directive will not function.',\n      )\n      // Store a flag or null to indicate failure, preventing handler execution\n      ;(el as any).__vuePrefetchFailedInject__ = true\n      return // Stop setup if client cannot be injected\n    }\n    // Store the successfully injected client instance on the element\n    ;(el as any).__vueQueryClient__ = queryClient\n\n    // --- Validate and Store Initial Options ---\n    if (!isValidBindingValue(binding.value)) {\n      console.warn('v-prefetch mounted: Initial binding value is invalid.', binding.value)\n      // Store null options to prevent handler running with bad initial data\n      ;(el as any).__vuePrefetchOptions__ = null\n    } else {\n      // Store initial options if valid\n      ;(el as any).__vuePrefetchOptions__ = binding.value\n    }\n\n    // --- Define the Handler ---\n    const prefetchHandler = () => {\n      // --- Retrieve Client and Options from the element ---\n      // Check the failure flag first\n      if ((el as any).__vuePrefetchFailedInject__) {\n        // console.warn('v-prefetch handler: Aborting, QueryClient injection failed during mount.');\n        return\n      }\n      const client = (el as any).__vueQueryClient__ as QueryClient // Cast should be safe due to check above\n      const options = (el as any).__vuePrefetchOptions__ as PrefetchOptions | null\n\n      // Check if options are valid *at the time of execution*\n      if (!options || !isValidBindingValue(options)) {\n        console.warn(\n          'v-prefetch handler: Prefetch options not found or invalid on element at execution time.',\n        )\n        return\n      }\n      // --- End Retrieval & Validation ---\n\n      // console.debug('[v-prefetch handler] Triggered. Using queryClient from element:', client);\n      // console.debug('[v-prefetch handler] Prefetching options:', options);\n\n      // Use the retrieved 'client' instance\n      client.prefetchQuery(options).catch((err) => {\n        console.error('v-prefetch failed:', err)\n      })\n    }\n\n    // Store handler on the element to remove it later\n    ;(el as any).__vuePrefetchHandler__ = prefetchHandler\n\n    // Add listeners\n    el.addEventListener('mouseenter', prefetchHandler)\n    el.addEventListener('focus', prefetchHandler)\n  },\n\n  updated(el, binding) {\n    // Update stored options if they change and are valid\n    if (isValidBindingValue(binding.value)) {\n      ;(el as any).__vuePrefetchOptions__ = binding.value\n    } else {\n      // If updated options are invalid, store null to prevent handler execution\n      console.warn('v-prefetch updated: New binding value is invalid.', binding.value)\n      ;(el as any).__vuePrefetchOptions__ = null\n    }\n    // We assume the queryClient instance doesn't change after mount.\n  },\n\n  beforeUnmount(el) {\n    const handler = (el as any).__vuePrefetchHandler__\n    if (handler) {\n      el.removeEventListener('mouseenter', handler)\n      el.removeEventListener('focus', handler)\n      // Clean up stored properties\n      delete (el as any).__vuePrefetchHandler__\n      delete (el as any).__vuePrefetchOptions__\n      delete (el as any).__vueQueryClient__\n      delete (el as any).__vuePrefetchFailedInject__ // Clean up flag\n    }\n  },\n}\n"
  },
  "main.ts": "import { createApp, type Ref, computed } from 'vue' // Import Ref and computed if needed elsewhere, but not for composable defs\nimport { createPinia } from 'pinia'\nimport { VueQueryPlugin, VueQueryPluginOptions } from '@tanstack/vue-query' // Import Vue Query Plugin\n\nimport App from './App.vue'\nimport router from './router'\nimport './assets/main.css'\n// Correct the import path if you renamed the store file\nimport { useAuthStore } from './stores/auth.store'\nimport { vPrefetch } from './directives/prefetch'\n\nconst app = createApp(App)\nconst pinia = createPinia()\n\n// Vue Query Options (Optional)\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClientConfig: {\n    defaultOptions: {\n      queries: {\n        staleTime: 5 * 60 * 1000, // Default stale time for all queries (5 minutes)\n        gcTime: 10 * 60 * 1000, // Default garbage collection time (10 minutes)\n        refetchOnWindowFocus: false, // Optional: disable refetch on window focus\n      },\n    },\n  },\n}\n\napp.use(pinia)\napp.use(router)\napp.use(VueQueryPlugin, vueQueryPluginOptions)\n\napp.directive('prefetch', vPrefetch)\n\n// Initialize Auth Store (Corrected import name)\nconst authStore = useAuthStore() // Use the correct store name\nauthStore\n  .init()\n  .then(() => {\n    console.log('Auth initialized, mounting app.')\n    app.mount('#app')\n  })\n  .catch((error) => {\n    console.error('Failed to initialize application:', error)\n    // Handle critical initialization failure (e.g., show error message)\n    // Mounting anyway might lead to a broken state\n    app.mount('#app')\n  })\n",
  "router": {
    "index.ts": "/**\n * @file Vue Router configuration.\n * Defines application routes, navigation guards, and lazy loading.\n */\nimport {\n  createRouter,\n  createWebHistory,\n  type RouteRecordRaw,\n  type NavigationGuardNext,\n  type RouteLocationNormalized,\n} from 'vue-router'\nimport HomeView from '@/views/HomeView.vue'\nimport { fetchTestamentBySlug } from '@/services/apiService' // Use the service layer\n\n// Define route names as constants for type safety and easier refactoring\nconst RouteNames = {\n  HOME: 'home',\n  TESTAMENT_DETAIL: 'testament-detail',\n  GENRE_DETAIL: 'genre-detail',\n  BOOK_DETAIL: 'book-detail',\n  NOT_FOUND: 'not-found',\n} as const // Use 'as const' for stricter typing\n\nconst routes: Array<RouteRecordRaw> = [\n  {\n    path: '/',\n    name: RouteNames.HOME,\n    component: HomeView,\n  },\n  {\n    path: '/:testamentSlug', // More descriptive path segment\n    name: RouteNames.TESTAMENT_DETAIL,\n    // Lazy load view components for better initial load performance\n    component: () => import('@/views/TestamentView.vue'),\n    props: true, // Pass route params as props\n    // Navigation guard to validate slug and potentially fetch ID (though component composable handles it now)\n    // This guard primarily acts as validation before loading the component.\n    beforeEnter: async (\n      to: RouteLocationNormalized,\n      from: RouteLocationNormalized,\n      next: NavigationGuardNext,\n    ) => {\n      const slug = to.params.testamentSlug as string\n      console.debug(`Route Guard (${String(to.name)}): Validating testament slug: ${slug}`)\n      if (!slug) {\n        console.warn(`Route Guard (${String(to.name)}): Invalid slug provided.`)\n        return next({ name: RouteNames.NOT_FOUND }) // Redirect if slug is missing\n      }\n      try {\n        // Validate slug exists via API service - doesn't need to pass ID anymore\n        await fetchTestamentBySlug(slug)\n        console.debug(`Route Guard (${String(to.name)}): Slug validated successfully.`)\n        next() // Proceed to load the component\n      } catch (error) {\n        console.error(\n          `Route Guard (${String(to.name)}): Error validating testament slug '${slug}':`,\n          error,\n        )\n        // Handle specific errors, e.g., not found\n        if (error instanceof Error && error.message.includes('not found')) {\n          next({ name: RouteNames.NOT_FOUND }) // Redirect to NotFound view\n        } else {\n          // For other errors, maybe show a generic error page or pass error info\n          // For simplicity, redirecting to NotFound here too.\n          next({ name: RouteNames.NOT_FOUND })\n          // Or: next(new Error(`Failed to load testament: ${error.message}`)); // Pass error to global handler if set up\n        }\n      }\n    },\n  },\n  {\n    // Nested structure makes sense semantically\n    path: '/:testamentSlug/:genreSlug',\n    name: RouteNames.GENRE_DETAIL,\n    component: () => import('@/views/GenreDetailView.vue'),\n    props: true,\n    // Optional: Add a beforeEnter guard similar to testament if needed for genre slug validation\n  },\n  {\n    // Keep the full path for clarity, even if nested logically\n    path: '/:testamentSlug/:genreSlug/:bookSlug',\n    name: RouteNames.BOOK_DETAIL,\n    component: () => import('@/views/BookDetailView.vue'),\n    props: true,\n    // Optional: Add a beforeEnter guard similar to testament if needed for book slug validation\n  },\n  {\n    // Catch-all 404 route - Must be last\n    path: '/:pathMatch(.*)*',\n    name: RouteNames.NOT_FOUND,\n    component: () => import('@/views/NotFoundView.vue'),\n  },\n]\n\nconst router = createRouter({\n  history: createWebHistory(import.meta.env.BASE_URL),\n  routes,\n  // Optional: Add scroll behavior\n  scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition\n    } else if (to.hash) {\n      // If navigating with a hash, scroll to the element\n      return { el: to.hash, behavior: 'smooth' }\n    } else {\n      // Otherwise, scroll to the top of the page on new navigation\n      return { top: 0, behavior: 'smooth' }\n    }\n  },\n})\n\nexport default router\n"
  },
  "services": {
    "apiService.ts": "/**\n * @file Centralized service for interacting with the Supabase database (Bible data).\n * Encapsulates all Supabase queries related to fetching biblical content.\n */\nimport supabase from '@/supabase'\nimport { getLanguageId } from '@/utils/language'\nimport type {\n  TestamentTranslation,\n  GenreTranslation,\n  BookWithTranslation,\n  BookSummary,\n  Chapter,\n  Version,\n  Verse,\n} from '@/types'\nimport { DEFAULT_LANGUAGE_NAME } from '@/constants'\n\n/**\n * Fetches testament translations for the default language.\n *\n * @returns A promise resolving to an array of testament translations.\n * @throws If there's an error during the fetch or language ID retrieval.\n */\nexport async function fetchTestaments(): Promise<TestamentTranslation[]> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n  const { data, error } = await supabase\n    .from('bible_testament_translations')\n    .select(\n      `\n      testament_id,\n      name,\n      slug,\n      bible_testaments ( testament_id )\n    `,\n    )\n    .eq('lang_id', langId)\n    .order('testament_id') // Use the base table's ID for ordering if possible\n\n  if (error) {\n    console.error('Error fetching testaments:', error)\n    throw new Error(`Failed to fetch testaments: ${error.message}`)\n  }\n  // Ensure testament_id is consistently available, handling potential null from relation\n  return (data || [])\n    .map((item) => ({\n      ...item,\n      testament_id: item.testament_id ?? item.testaments?.testament_id,\n    }))\n    .filter((item) => item.testament_id != null) as TestamentTranslation[] // Genre assertion after filtering nulls\n}\n\n/**\n * Fetches details (name, ID) for a specific testament by its slug.\n *\n * @param slug - The URL slug of the testament.\n * @returns A promise resolving to the testament translation details.\n * @throws If the testament is not found or if there's a fetch error.\n */\nexport async function fetchTestamentBySlug(\n  slug: string,\n): Promise<Pick<TestamentTranslation, 'name' | 'testament_id'>> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n  const { data, error } = await supabase\n    .from('bible_testament_translations')\n    .select('name, testament_id')\n    .eq('slug', slug)\n    .eq('lang_id', langId)\n    .single()\n\n  if (error) {\n    console.error(`Error fetching testament by slug '${slug}':`, error)\n    if (error.code === 'PGRST116') {\n      // Not found\n      throw new Error(`Testament with slug '${slug}' not found for the selected language.`)\n    }\n    throw new Error(`Failed to fetch testament details: ${error.message}`)\n  }\n  if (!data) {\n    throw new Error(`Testament with slug '${slug}' not found (no data returned).`)\n  }\n\n  return data\n}\n\n/**\n * Fetches distinct book genre translations associated with a specific testament.\n *\n * @param testamentId - The ID of the testament.\n * @returns A promise resolving to an array of genre translations.\n * @throws If there's an error during the fetch.\n */\nexport async function fetchGenresForTestament(testamentId: number): Promise<GenreTranslation[]> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n\n  // Step 1: Find distinct genre_ids for books within the testament\n  const { data: bookGenreData, error: bookGenreError } = await supabase\n    .from('bible_books')\n    .select('genre_id')\n    .eq('testament_id', testamentId)\n    .not('genre_id', 'is', null) // Ensure genre_id is not null\n\n  if (bookGenreError) {\n    console.error(`Error fetching book genres for testament ${testamentId}:`, bookGenreError)\n    throw new Error(`Failed to fetch book genre associations: ${bookGenreError.message}`)\n  }\n\n  // Extract unique, non-null genre IDs\n  const distinctGenreIds = [\n    ...new Set(\n      bookGenreData?.map((item) => item.genre_id).filter((id): id is number => id !== null) ?? [],\n    ),\n  ]\n\n  if (distinctGenreIds.length === 0) {\n    console.log(`No distinct book genres found for testament ID ${testamentId}.`)\n    return [] // No genres associated\n  }\n\n  // Step 2: Fetch the translations for these distinct genre IDs\n  const { data: genreTranslationsData, error: translationError } = await supabase\n    .from('bible_genre_translations')\n    .select('name, slug, genre_id')\n    .in('genre_id', distinctGenreIds)\n    .eq('lang_id', langId)\n    .order('genre_id') // Or order by name if preferred: .order('name')\n\n  if (translationError) {\n    console.error(\n      `Error fetching genre translations for testament ${testamentId}:`,\n      translationError,\n    )\n    throw new Error(`Failed to fetch genre names: ${translationError.message}`)\n  }\n\n  return genreTranslationsData || []\n}\n\n/**\n * Fetches details (name, ID) for a specific book genre by its slug.\n *\n * @param slug - The URL slug of the book genre.\n * @returns A promise resolving to the genre translation details.\n * @throws If the genre is not found or if there's a fetch error.\n */\nexport async function fetchGenreBySlug(\n  slug: string,\n): Promise<Pick<GenreTranslation, 'name' | 'genre_id'>> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n  const { data, error } = await supabase\n    .from('bible_genre_translations')\n    .select('name, genre_id')\n    .eq('slug', slug)\n    .eq('lang_id', langId)\n    .single()\n\n  if (error) {\n    console.error(`Error fetching genre by slug '${slug}':`, error)\n    if (error.code === 'PGRST116') {\n      // Not found\n      throw new Error(`Genre with slug '${slug}' not found for the selected language.`)\n    }\n    throw new Error(`Failed to fetch genre details: ${error.message}`)\n  }\n  if (!data) {\n    throw new Error(`Genre with slug '${slug}' not found (no data returned).`)\n  }\n  return data\n}\n\n/**\n * Fetches books belonging to a specific genre ID, including their translations.\n *\n * @param genreId - The ID of the book genre.\n * @returns A promise resolving to an array of book summaries.\n * @throws If there's an error during the fetch.\n */\nexport async function fetchBooksByGenre(genreId: number): Promise<BookSummary[]> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n  const { data, error } = await supabase\n    .from('bible_books')\n    .select(\n      `\n      book_id,\n      bible_order,\n      bible_book_translations!inner (\n          title,\n          abbr,\n          slug,\n          lang_id\n      )\n    `,\n    )\n    .eq('genre_id', genreId)\n    .eq('bible_book_translations.lang_id', langId) // Filter translations by language\n    .order('bible_order')\n\n  if (error) {\n    console.error(`Error fetching books for genre ${genreId}:`, error)\n    throw new Error(`Failed to fetch books: ${error.message}`)\n  }\n\n  // Map the potentially complex nested structure to a flat BookSummary\n  return (data || [])\n    .filter(\n      (book): book is BookWithTranslation =>\n        book.bible_book_translations && book.bible_book_translations.length > 0, // Genre guard to ensure translation exists\n    )\n    .map((book) => ({\n      book_id: book.book_id,\n      bible_order: book.bible_order,\n      // Assuming inner join guarantees one translation, but check just in case\n      title: book.bible_book_translations[0]?.title || 'Unknown Title',\n      abbr: book.bible_book_translations[0]?.abbr || 'N/A',\n      slug: book.bible_book_translations[0]?.slug || `book-${book.book_id}`, // Fallback slug\n    }))\n}\n\n/**\n * Fetches details (title, ID) for a specific book by its slug.\n *\n * @param slug - The URL slug of the book.\n * @returns A promise resolving to the book translation details.\n * @throws If the book is not found or if there's a fetch error.\n */\nexport async function fetchBookBySlug(\n  slug: string,\n): Promise<Pick<BookWithTranslation['book_translations'][0], 'title'> & { book_id: number }> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n  const { data, error } = await supabase\n    .from('bible_book_translations')\n    .select('title, book_id') // Select book_id from the related book table\n    .eq('slug', slug)\n    .eq('lang_id', langId)\n    .single()\n\n  if (error) {\n    console.error(`Error fetching book by slug '${slug}':`, error)\n    if (error.code === 'PGRST116') {\n      // Not found\n      throw new Error(`Book with slug '${slug}' not found for the selected language.`)\n    }\n    throw new Error(`Failed to fetch book details: ${error.message}`)\n  }\n  if (!data || data.book_id === null) {\n    // Ensure book_id is present\n    throw new Error(`Book with slug '${slug}' not found or missing book ID.`)\n  }\n\n  // We need to cast book_id because Supabase might return it as potentially null from the join\n  return { title: data.title, book_id: data.book_id as number }\n}\n\n/**\n * Fetches available Bible versions for the default language.\n *\n * @returns A promise resolving to an array of versions.\n * @throws If there's an error during the fetch.\n */\nexport async function fetchAvailableVersions(): Promise<Version[]> {\n  const langId = await getLanguageId(DEFAULT_LANGUAGE_NAME)\n  const { data, error } = await supabase\n    .from('bible_versions')\n    .select('version_id, abbr, full_name, lang_id')\n    .eq('lang_id', langId)\n    .order('abbr')\n\n  if (error) {\n    console.error('Error fetching available versions:', error)\n    throw new Error(`Failed to load versions: ${error.message}`)\n  }\n  return data || []\n}\n\n/**\n * Fetches chapters for a specific book ID.\n *\n * @param bookId - The ID of the book.\n * @returns A promise resolving to an array of chapters.\n * @throws If there's an error during the fetch.\n */\nexport async function fetchChaptersForBook(bookId: number): Promise<Chapter[]> {\n  const { data, error } = await supabase\n    .from('bible_chapters')\n    .select('chapter_id, chapter_number, book_id')\n    .eq('book_id', bookId)\n    .order('chapter_number')\n\n  if (error) {\n    console.error(`Error fetching chapters for book ${bookId}:`, error)\n    throw new Error(`Failed to load chapters: ${error.message}`)\n  }\n  return data || []\n}\n\n/**\n * Fetches verses for a specific chapter and version ID.\n *\n * @param chapterId - The ID of the chapter.\n * @param versionId - The ID of the Bible version.\n * @returns A promise resolving to an array of verses.\n * @throws If there's an error during the fetch.\n */\nexport async function fetchVersesForChapter(\n  chapterId: number,\n  versionId: number,\n): Promise<Verse[]> {\n  const { data, error } = await supabase\n    .from('bible_verses')\n    .select('verse_id, verse_number, verse_text, chapter_id, version_id')\n    .eq('chapter_id', chapterId)\n    .eq('version_id', versionId)\n    .order('verse_number')\n\n  if (error) {\n    console.error(`Error fetching verses for chapter ${chapterId}, version ${versionId}:`, error)\n    throw new Error(`Failed to load verses: ${error.message}`)\n  }\n  return data || []\n}\n"
  },
  "stores": {
    "auth.store.ts": "/**\n * @file Pinia store for managing Supabase authentication state and actions.\n */\nimport { defineStore } from 'pinia'\nimport { ref, computed, type Ref } from 'vue'\nimport supabase from '@/supabase'\nimport type {\n  AuthError,\n  Session,\n  User,\n  SignInWithPasswordCredentials,\n  SignUpWithPasswordCredentials,\n} from '@supabase/supabase-js'\n\n// Define the state structure with explicit types\ninterface AuthState {\n  user: User | null\n  session: Session | null\n  isLoading: boolean\n  error: string | null\n}\n\nexport const useAuthStore = defineStore('auth', () => {\n  // --- State ---\n  const user: Ref<User | null> = ref(null)\n  const session: Ref<Session | null> = ref(null)\n  const isLoading: Ref<boolean> = ref(false)\n  const error: Ref<string | null> = ref(null)\n\n  // --- Getters ---\n  const isLoggedIn = computed<boolean>(() => !!user.value)\n  const userId = computed<string | undefined>(() => user.value?.id)\n\n  // --- Internal Actions ---\n\n  /**\n   * Sets the error message and clears it after a delay.\n   * @param errorMessage - The error message string.\n   * @param timeoutMs - Duration in milliseconds before clearing the error. Defaults to 5000.\n   */\n  function setError(errorMessage: string | null, timeoutMs = 5000): void {\n    error.value = errorMessage\n    if (errorMessage !== null) {\n      setTimeout(() => {\n        if (error.value === errorMessage) {\n          // Clear only if it hasn't been overwritten\n          error.value = null\n        }\n      }, timeoutMs)\n    }\n  }\n\n  /**\n   * Centralized loading state management.\n   * @param loading - Boolean indicating the loading state.\n   */\n  function setLoading(loading: boolean): void {\n    isLoading.value = loading\n  }\n\n  /**\n   * Updates the user and session state.\n   * @param newSession - The new session object from Supabase, or null.\n   */\n  function updateAuthState(newSession: Session | null): void {\n    session.value = newSession\n    user.value = newSession?.user ?? null\n    console.debug('Auth state updated:', event, newSession)\n  }\n\n  // --- Actions ---\n\n  /**\n   * Initializes the auth state by fetching the current session and setting up the listener.\n   * Should be called once when the application starts.\n   */\n  async function init(): Promise<void> {\n    setLoading(true)\n    setError(null)\n    console.debug('Initializing auth store...')\n    try {\n      // Attempt to get the initial session\n      const { data: initialSessionData, error: sessionError } = await supabase.auth.getSession()\n      if (sessionError) {\n        console.error('Error getting initial session:', sessionError)\n        // Don't throw here, allow app to load, but log the error\n        setError(`Failed to retrieve initial session: ${sessionError.message}`)\n      } else {\n        updateAuthState(initialSessionData.session)\n      }\n\n      // Set up listener for subsequent auth changes\n      const { data: authListener } = supabase.auth.onAuthStateChange((event, newSession) => {\n        updateAuthState(newSession)\n      })\n\n      // Consider storing the subscription to unsubscribe on app teardown if needed\n      // E.g., store `authListener.subscription` and call `unsubscribe()` later.\n      console.debug('Auth listener attached.')\n    } catch (err) {\n      console.error('Critical error during auth initialization:', err)\n      setError(err instanceof Error ? err.message : 'An unknown error occurred during auth setup.')\n      // Update state to reflect failure\n      updateAuthState(null)\n    } finally {\n      setLoading(false)\n      console.debug('Auth store initialization complete.')\n    }\n  }\n\n  /**\n   * Signs in a user using email and password.\n   * @param credentials - Object containing email and password.\n   * @returns A promise resolving to an object indicating success or failure.\n   */\n  async function signInWithEmail(\n    credentials: SignInWithPasswordCredentials,\n  ): Promise<{ success: boolean; error?: AuthError }> {\n    setLoading(true)\n    setError(null)\n    try {\n      const { data, error: authError } = await supabase.auth.signInWithPassword(credentials)\n\n      if (authError) {\n        console.error('Sign-in error:', authError)\n        throw authError // Throw to be caught below\n      }\n\n      // Auth state will be updated by the onAuthStateChange listener\n      // updateAuthState(data.session); // Avoid redundant update if listener works reliably\n      return { success: true }\n    } catch (err) {\n      const authError = err as AuthError\n      setError(authError.message || 'Failed to sign in.')\n      console.error('Sign in action failed:', authError)\n      return { success: false, error: authError }\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  /**\n   * Signs up a new user using email and password.\n   * @param credentials - Object containing email and password.\n   * @returns A promise resolving to an object indicating success or failure.\n   */\n  async function signUpWithEmail(\n    credentials: SignUpWithPasswordCredentials,\n  ): Promise<{ success: boolean; error?: AuthError }> {\n    setLoading(true)\n    setError(null)\n    try {\n      // Note: Supabase might require email confirmation depending on settings.\n      // The user object in the response might be null until confirmed.\n      const { data, error: authError } = await supabase.auth.signUp(credentials)\n\n      if (authError) {\n        console.error('Sign-up error:', authError)\n        throw authError\n      }\n\n      // User might need to confirm email. State might not update immediately.\n      console.log('Sign-up successful (check email for confirmation if enabled). User:', data.user)\n      return { success: true }\n    } catch (err) {\n      const authError = err as AuthError\n      setError(authError.message || 'Failed to sign up.')\n      console.error('Sign up action failed:', authError)\n      return { success: false, error: authError }\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  /**\n   * Signs out the current user.\n   * @returns A promise resolving to an object indicating success or failure.\n   */\n  async function signOut(): Promise<{ success: boolean; error?: AuthError }> {\n    setLoading(true)\n    setError(null)\n    try {\n      const { error: authError } = await supabase.auth.signOut()\n\n      if (authError) {\n        console.error('Sign-out error:', authError)\n        throw authError\n      }\n\n      // Auth state will be updated by the onAuthStateChange listener\n      // updateAuthState(null); // Avoid redundant update\n      return { success: true }\n    } catch (err) {\n      const authError = err as AuthError\n      setError(authError.message || 'Failed to sign out.')\n      console.error('Sign out action failed:', authError)\n      return { success: false, error: authError }\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  // --- Return Store API ---\n  return {\n    // State refs (read-only recommended for direct use in components)\n    user: computed(() => user.value), // Expose as computed for read-only access\n    session: computed(() => session.value),\n    isLoading: computed(() => isLoading.value),\n    error: computed(() => error.value),\n\n    // Getters\n    isLoggedIn,\n    userId,\n\n    // Actions\n    init,\n    signInWithEmail,\n    signUpWithEmail,\n    signOut,\n  }\n})\n"
  },
  "supabase.ts": "/**\n * @file Initializes and exports the Supabase client instance.\n */\nimport { createClient, SupabaseClient } from '@supabase/supabase-js'\nimport type { Database } from './types/supabase'\n\nconst supabaseUrl: string | undefined = import.meta.env.VITE_SUPABASE_URL\nconst supabaseAnonKey: string | undefined = import.meta.env.VITE_SUPABASE_ANON_KEY\n\nif (!supabaseUrl || !supabaseAnonKey) {\n  const errorMessage =\n    'Supabase environment variables are missing. Make sure VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY are set in your .env file.'\n  console.error(errorMessage)\n  // In a real app, you might want to show this error to the user or halt initialization gracefully.\n  throw new Error('Supabase configuration is incomplete.')\n}\n\n// Initialize the Supabase client with generated types for better type safety\nconst supabase: SupabaseClient<Database> = createClient<Database>(supabaseUrl, supabaseAnonKey)\n\nexport default supabase\n",
  "types": {
    "api.ts": "/**\n * @file TypeScript interfaces for API data structures.\n */\n\nexport interface Language {\n  lang_id: number\n  lang: string\n  // Add other fields if needed\n}\n\nexport interface Testament {\n  testament_id: number\n  // Add other base testament fields if needed\n}\n\nexport interface TestamentTranslation {\n  testament_translation_id: number // Assuming a primary key exists\n  testament_id: number\n  lang_id: number\n  name: string\n  slug: string\n  testaments?: Testament // Relation might be included\n}\n\nexport interface BookGenre {\n  genre_id: number\n  // Add other base genre fields if needed\n}\n\nexport interface GenreTranslation {\n  genre_translation_id: number // Assuming a primary key exists\n  genre_id: number\n  lang_id: number\n  name: string\n  slug: string\n}\n\nexport interface Book {\n  book_id: number\n  testament_id: number\n  genre_id: number | null\n  bible_order: number\n  // Add other base book fields if needed\n}\n\n// Type for the structure returned when joining bible_books and bible_book_translations\nexport interface BookWithTranslation extends Book {\n  bible_book_translations: Array<{\n    book_translation_id: number // Assuming a primary key exists\n    title: string\n    abbr: string\n    slug: string\n    lang_id: number\n  }>\n}\n\n// Simplified structure often used in components\nexport interface BookSummary {\n  book_id: number\n  bible_order: number\n  title: string\n  abbr: string\n  slug: string\n}\n\nexport interface Chapter {\n  chapter_id: number\n  book_id: number\n  chapter_number: number\n}\n\nexport interface Version {\n  version_id: number\n  lang_id: number\n  abbr: string\n  full_name: string\n}\n\nexport interface Verse {\n  verse_id: number\n  chapter_id: number\n  version_id: number\n  verse_number: number\n  verse_text: string\n}\n",
    "index.ts": "/**\n * @file Barrel file for exporting all types.\n */\nexport * from './api'\nexport * from './vue'\n",
    "vue.ts": "/**\n * @file Common Vue related type definitions (Props, Emits).\n */\n\n// Example Prop Type (adjust as needed per component)\nexport interface ExampleComponentProps {\n  message: string\n  count?: number\n}\n\n// Example Emit Type (adjust as needed per component)\nexport type ExampleComponentEmits = {\n  update: [value: string] // Emits 'update' with a string payload\n  close: [] // Emits 'close' with no payload\n}\n"
  },
  "utils": {
    "language.ts": "/**\n * @file Language related utility functions.\n */\nimport supabase from '@/supabase'\nimport { DEFAULT_LANGUAGE_NAME } from '@/constants'\n\n// Simple in-memory cache for language IDs\nconst languageIdCache: Record<string, number> = {}\n\n/**\n * Retrieves the language ID for a given language name from Supabase.\n * Caches the result in memory to avoid redundant database calls.\n *\n * @param langName - The name of the language (e.g., \"Français\"). Defaults to DEFAULT_LANGUAGE_NAME.\n * @returns A promise that resolves with the language ID.\n * @throws If the language is not found or if there's a database error.\n * @example\n * const frenchId = await getLanguageId();\n * const englishId = await getLanguageId('English');\n */\nexport const getLanguageId = async (langName: string = DEFAULT_LANGUAGE_NAME): Promise<number> => {\n  if (languageIdCache[langName]) {\n    return languageIdCache[langName]\n  }\n\n  console.debug(`Fetching language ID for: ${langName}`)\n  try {\n    const { data, error } = await supabase\n      .from('languages')\n      .select('lang_id')\n      .eq('lang', langName)\n      .single()\n\n    if (error) {\n      console.error(`Supabase error fetching language ID for ${langName}:`, error)\n      throw new Error(`Database error fetching language ID: ${error.message}`)\n    }\n    if (!data) {\n      throw new Error(`Language '${langName}' not found in the database.`)\n    }\n\n    console.debug(`Found language ID for ${langName}: ${data.lang_id}`)\n    languageIdCache[langName] = data.lang_id\n    return data.lang_id\n  } catch (err) {\n    console.error(`Error in getLanguageId for ${langName}:`, err)\n    // Re-throw the specific error for better context upstream\n    if (err instanceof Error) {\n      throw err\n    } else {\n      throw new Error(`An unknown error occurred while fetching language ID for ${langName}.`)\n    }\n  }\n}\n",
    "prefetchHelpers.ts": "// src/utils/prefetchHelpers.ts\nimport { inject } from 'vue'\nimport { QueryClient, VUE_QUERY_CLIENT } from '@tanstack/vue-query'\nimport {\n  fetchBookBySlug,\n  fetchChaptersForBook,\n  fetchAvailableVersions,\n  fetchVersesForChapter, // <-- Import verse fetcher\n} from '@/services/apiService'\nimport type { PrefetchOptions } from '@tanstack/vue-query'\n\ninterface PrefetchHelperResult extends PrefetchOptions {}\n\n/**\n * Creates prefetch options for navigating to a Book Detail view.\n * It fetches the book details first, then uses the resulting book_id\n * to fetch the chapters list. Concurrently, it prefetches Bible versions.\n * Finally, it attempts to prefetch the verses for the *first chapter*\n * using a default version ID (assumed to be 1).\n *\n * @param bookSlug - The slug of the book to prefetch details for.\n * @returns An object containing queryKey, queryFn, and staleTime suitable for prefetch.\n */\nexport function createBookPrefetchOptions(bookSlug: string): PrefetchHelperResult {\n  const primaryQueryKey = ['book_detail', bookSlug]\n  const defaultVersionIdForPrefetch = 1 // Assume version 1 for verse prefetch\n\n  const combinedQueryFn = async () => {\n    const queryClient = inject<QueryClient>(VUE_QUERY_CLIENT)\n    if (!queryClient) {\n      console.warn('[Prefetch Helper] QueryClient not available.')\n      return null\n    }\n\n    console.debug(`[Prefetch Helper] Running prefetch sequence for slug: ${bookSlug}`)\n    try {\n      // --- Step 1: Fetch Book Details (Need Result for book_id) ---\n      const bookDetails = await queryClient.fetchQuery({\n        queryKey: primaryQueryKey,\n        queryFn: () => fetchBookBySlug(bookSlug),\n        staleTime: 5 * 60 * 1000, // 5 minutes\n      })\n\n      if (bookDetails?.book_id) {\n        const bookId = bookDetails.book_id\n        console.debug(\n          `[Prefetch Helper]   Got bookId: ${bookId}. Fetching chapters & prefetching versions.`,\n        )\n\n        // --- Step 2a: Fetch Chapters (Need Result for first chapter_id) ---\n        // Use fetchQuery as we need the result immediately for verse prefetch\n        const chaptersPromise = queryClient.fetchQuery({\n          queryKey: ['chapters', bookId],\n          queryFn: () => fetchChaptersForBook(bookId),\n          staleTime: 5 * 60 * 1000, // Keep chapters fresh too\n        })\n\n        // --- Step 2b: Prefetch Versions (Run concurrently) ---\n        const versionsPromise = queryClient.prefetchQuery({\n          queryKey: ['bible_versions'],\n          queryFn: fetchAvailableVersions,\n          staleTime: 10 * 60 * 1000,\n        })\n\n        // Wait for chapters to be fetched\n        const chapters = await chaptersPromise\n\n        // --- Step 3: Prefetch First Chapter Verses (If chapters loaded) ---\n        if (chapters && chapters.length > 0) {\n          const firstChapterId = chapters[0].chapter_id\n          console.debug(\n            `[Prefetch Helper]   Got first chapterId: ${firstChapterId}. Prefetching verses for default version ${defaultVersionIdForPrefetch}.`,\n          )\n\n          // Don't wait for this, just fire and forget\n          queryClient\n            .prefetchQuery({\n              queryKey: ['verses', firstChapterId, defaultVersionIdForPrefetch], // Key matches useVerses\n              queryFn: () => fetchVersesForChapter(firstChapterId, defaultVersionIdForPrefetch),\n              staleTime: 1 * 60 * 1000, // Keep verses fresh for 1 minute\n            })\n            .catch((err) => {\n              // Log verse prefetch errors but don't block anything\n              console.warn(\n                `[Prefetch Helper]   Verse prefetch failed (this might be ok):`,\n                err.message,\n              )\n            })\n        } else {\n          console.debug(\n            `[Prefetch Helper]   No chapters found or chapters failed to load, skipping verse prefetch.`,\n          )\n        }\n\n        // Optional: Wait for versions prefetch if needed elsewhere, but not strictly necessary here\n        await versionsPromise // Ensure versions are at least initiated\n      } else {\n        console.warn(\n          `[Prefetch Helper]   Could not get book_id for slug ${bookSlug}, skipping secondary fetches.`,\n        )\n      }\n\n      return bookDetails // Return primary data\n    } catch (error) {\n      console.error(`[Prefetch Helper] Error during prefetch sequence for slug ${bookSlug}:`, error)\n      throw error\n    }\n  }\n\n  return {\n    queryKey: primaryQueryKey,\n    queryFn: combinedQueryFn,\n    staleTime: 60 * 1000, // Stale time for the overall prefetch action\n  }\n}\n"
  },
  "views": {
    "BookDetailView.vue": "<template>\n  <div class=\"book-detail-view container\">\n    <header class=\"view-header book-header\">\n      <BaseLoadingIndicator v-if=\"isLoadingBook\" message=\"Loading book details...\" />\n      <BaseErrorMessage v-if=\"isErrorBook\" :message=\"errorBook?.message\" />\n\n      <template v-if=\"!isLoadingBook && !isErrorBook && bookTitle\">\n        <h1>{{ bookTitle }}</h1>\n\n        <BaseLoadingIndicator v-if=\"isLoadingVersions\" message=\"Loading versions...\" />\n        <BaseErrorMessage v-if=\"isErrorVersions\" :message=\"errorVersions?.message\" />\n        <div v-if=\"!isLoadingVersions && !isErrorVersions && versions && versions.length > 1\" class=\"version-selector\">\n          <label for=\"versionSelect\">Version:</label>\n          <select id=\"versionSelect\" v-model=\"selectedVersionId\">\n            <option :value=\"null\" disabled>Select Version</option>\n            <option v-for=\"version in versions\" :key=\"version.version_id\" :value=\"version.version_id\">\n              {{ version.abbr }} ({{ version.full_name }})\n            </option>\n          </select>\n        </div>\n        <p v-if=\"!isLoadingVersions && !isErrorVersions && versions && versions.length === 1\" class=\"single-version\">\n          Version: {{ versions[0].abbr }}\n        </p>\n        <p v-if=\"!isLoadingVersions && !isErrorVersions && versions && versions.length === 0\" class=\"no-results\">\n          No Bible versions found.\n        </p>\n      </template>\n      <h1 v-if=\"!isLoadingBook && !isErrorBook && !bookTitle\">Book Not Found</h1>\n    </header>\n\n    <main v-if=\"bookId && selectedVersionId\">\n      <BaseLoadingIndicator v-if=\"isLoadingChapters\" message=\"Loading chapters...\" />\n      <BaseErrorMessage v-if=\"isErrorChapters\" :message=\"errorChapters?.message\" />\n      <nav v-if=\"!isLoadingChapters && !isErrorChapters && chapters && chapters.length > 1\" class=\"chapter-nav\">\n        <button @click=\"changeChapter(-1)\" :disabled=\"selectedChapterNumber <= 1\" aria-label=\"Previous Chapter\">\n          < Prev </button>\n            <span role=\"status\" aria-live=\"polite\">\n              Chapter {{ selectedChapterNumber }} of {{ chapters.length }}\n            </span>\n            <button @click=\"changeChapter(1)\" :disabled=\"selectedChapterNumber >= chapters.length\"\n              aria-label=\"Next Chapter\">\n              Next >\n            </button>\n      </nav>\n      <h2 v-else-if=\"!isLoadingChapters && !isErrorChapters && chapters && chapters.length === 1\"\n        class=\"single-chapter-heading\">\n        Chapter {{ selectedChapterNumber }}\n      </h2>\n      <p v-if=\"!isLoadingChapters && !isErrorChapters && chapters && chapters.length === 0\" class=\"no-results\">\n        No chapters found for this book.\n      </p>\n\n      <div v-if=\"selectedChapterId\" class=\"content-area\">\n        <BaseLoadingIndicator v-if=\"isLoadingVerses\" message=\"Loading content...\" />\n        <BaseErrorMessage v-if=\"isErrorVerses\" :message=\"errorVerses?.message\" />\n        <div v-if=\"!isLoadingVerses && !isErrorVerses && verses && verses.length > 0\" class=\"verses-container\">\n          <p v-for=\"verse in verses\" :key=\"verse.verse_id\" class=\"verse\">\n            <sup :id=\"`v${selectedChapterNumber}-${verse.verse_number}`\">{{ verse.verse_number }}</sup>\n            {{ verse.verse_text }}\n          </p>\n        </div>\n        <p v-if=\"!isLoadingVerses && !isErrorVerses && verses && verses.length === 0 && chapters && chapters.length > 0\"\n          class=\"no-results\">\n          No verses found for Chapter {{ selectedChapterNumber }} in the selected version.\n        </p>\n      </div>\n      <div v-else-if=\"!isLoadingChapters && !isErrorChapters && chapters && chapters.length > 0\">\n        <p class=\"no-results\">Select a chapter.</p>\n      </div>\n\n    </main>\n    <div v-else-if=\"!isLoadingBook && !isErrorBook && !bookId\">\n      <p class=\"no-results\">Could not determine book details to load content.</p>\n    </div>\n    <div v-else-if=\"!isLoadingVersions && !isErrorVersions && !selectedVersionId && versions && versions.length > 0\">\n      <p class=\"no-results\">Please select a Bible version to view content.</p>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, watch, type Ref } from 'vue';\nimport { useDelayedTrueState } from '@/composables/useDelayedState';\n// No longer need useRoute if slug comes from props\nimport {\n  useBookDetails,\n  useBibleVersions,\n  useChapters,\n  useVerses,\n} from '@/composables/useBibleData';\nimport BaseLoadingIndicator from '@/components/BaseLoadingIndicator.vue';\nimport BaseErrorMessage from '@/components/BaseErrorMessage.vue';\nimport type { Chapter, Version } from '@/types';\n\ninterface Props {\n  bookSlug: string;\n}\nconst props = defineProps<Props>();\n\nconst bookSlugRef = computed(() => props.bookSlug);\n\n// --- Local State Refs ---\nconst selectedVersionId = ref<number | null>(null);\nconst selectedChapterId = ref<number | null>(null);\nconst selectedChapterNumber = ref<number>(1); // Default to chapter 1\n\n// --- Composables (Vue Query) ---\n\n// 1. Fetch Book Details (Title, ID) based on Slug\nconst {\n  data: bookDetailsData, // Raw data { title, book_id } | null\n  isLoading: isLoadingBookRaw,\n  isError: isErrorBook,\n  error: errorBook\n} = useBookDetails(bookSlugRef as Ref<string | undefined>);\n\n// Recreate computed properties for book title and ID\nconst bookTitle = computed(() => bookDetailsData.value?.title ?? '');\nconst bookId = computed(() => bookDetailsData.value?.book_id ?? null); // Ref<number | null>\n\n// 2. Fetch Available Versions (runs automatically via Vue Query)\nconst {\n  data: versions, // Ref<Version[] | undefined>\n  isLoading: isLoadingVersionsRaw,\n  isError: isErrorVersions,\n  error: errorVersions\n} = useBibleVersions();\n\n// 3. Fetch Chapters (enabled when bookId is valid)\nconst {\n  data: chapters, // Ref<Chapter[] | undefined>\n  isLoading: isLoadingChaptersRaw,\n  isError: isErrorChapters,\n  error: errorChapters\n} = useChapters(bookId); // Pass reactive bookId ref\n\n// 4. Fetch Verses (enabled when chapterId and versionId are valid)\nconst {\n  data: verses, // Ref<Verse[] | undefined>\n  isLoading: isLoadingVersesRaw,\n  isError: isErrorVerses,\n  error: errorVerses,\n  status: versesStatus,\n  isFetching: isFetchingVerses\n  // refetch: refetchVerses\n} = useVerses(selectedChapterId, selectedVersionId);\n\n// --- Delayed Loaders ---\nconst isLoadingBook = useDelayedTrueState(isLoadingBookRaw, 750); // 750ms delay\nconst isLoadingVersions = useDelayedTrueState(isLoadingVersionsRaw, 750);\nconst isLoadingChapters = useDelayedTrueState(isLoadingChaptersRaw, 750);\nconst isLoadingVerses = useDelayedTrueState(isLoadingVersesRaw, 750);\n\n// --- Watchers and Logic ---\n\n// Set default/initial version once versions load\nwatch(versions, (newVersions) => {\n  console.log('[Watcher versions] Running. newVersions:', newVersions, 'selectedVersionId currently:', selectedVersionId.value);\n\n  // Only proceed if versions are loaded, there are versions, and none is selected yet\n  if (newVersions && newVersions.length > 0 && !selectedVersionId.value) {\n    console.log('[Watcher versions] Conditions met: Has new versions, length > 0, none selected yet.');\n    console.log('[Watcher versions] Available versions:', JSON.parse(JSON.stringify(newVersions)));\n\n    let versionToSelect: Version | undefined = undefined; // Use the actual Version type\n\n    // 1. Prioritize version with ID 1\n    versionToSelect = newVersions.find(v => v.version_id === 1);\n\n    if (versionToSelect) {\n      console.log(`[Watcher versions] Found priority version ID 1: ${versionToSelect.abbr}. Setting selectedVersionId.`);\n    } else {\n      // 2. If ID 1 not found, fallback to the *first* version in the list\n      console.log(`[Watcher versions] Priority version ID 1 not found. Falling back to the first available version.`);\n      versionToSelect = newVersions[0]; // Select the first one\n      if (versionToSelect) {\n        console.log(`[Watcher versions] Selected first available version: ${versionToSelect.abbr} (ID: ${versionToSelect.version_id}). Setting selectedVersionId.`);\n      }\n    }\n\n    // Set the selected ID if we found a version to select\n    if (versionToSelect) {\n      selectedVersionId.value = versionToSelect.version_id;\n    } else {\n      // This case should theoretically not happen if newVersions.length > 0\n      console.warn('[Watcher versions] Could not determine a version to select, though versions array is not empty.');\n    }\n\n  } else {\n    console.log('[Watcher versions] Conditions NOT met. Reasons:', {\n      hasNewVersions: !!newVersions,\n      length: newVersions?.length,\n      isSelected: !!selectedVersionId.value\n    });\n  }\n}, { immediate: true });\n\n// --- ADD LOGGING FOR VERSES ---\nwatch(versesStatus, (newStatus) => {\n  console.log(`%c[Verse Watcher] Verses Status: ${newStatus}`, 'color: green;');\n  if (newStatus === 'success') {\n    // Use JSON stringify/parse for cleaner logging of proxy object\n    console.log(`%c[Verse Watcher] Verses Data:`, 'color: green; font-weight: bold;', verses.value ? JSON.parse(JSON.stringify(verses.value)) : 'undefined');\n  }\n  if (newStatus === 'error') {\n    console.error(`%c[Verse Watcher] Verses Error:`, 'color: red; font-weight: bold;', errorVerses.value?.message);\n  }\n});\n\nwatch(isFetchingVerses, (fetching) => {\n  console.log(`%c[Verse Watcher] Verses isFetching: ${fetching}`, 'color: green;');\n});\n// Set initial/current chapter once chapters load\nwatch(chapters, (newChapters) => {\n  if (newChapters && newChapters.length > 0) {\n    // Find chapter matching selectedChapterNumber OR default to first chapter\n    const targetChapter = newChapters.find(ch => ch.chapter_number === selectedChapterNumber.value) || newChapters[0];\n    if (targetChapter && targetChapter.chapter_id !== selectedChapterId.value) {\n      console.debug(`Setting current chapter: ${targetChapter.chapter_number} (ID: ${targetChapter.chapter_id})`);\n      selectedChapterId.value = targetChapter.chapter_id;\n      selectedChapterNumber.value = targetChapter.chapter_number; // Ensure consistency\n    } else if (!targetChapter) {\n      console.warn(\"Could not find target chapter.\");\n      selectedChapterId.value = null; // Reset if no chapter found\n    }\n  }\n  // Reset chapter if chapters become empty/undefined (e.g., book changes)\n  else if (!newChapters || newChapters.length === 0) {\n    selectedChapterId.value = null;\n    selectedChapterNumber.value = 1; // Reset to default\n  }\n}, { immediate: true }); // Check immediately when chapters data arrives\n\n// Reset chapter selection if book changes\nwatch(bookId, () => {\n  console.debug(\"Book ID changed, resetting chapter selection.\");\n  selectedChapterId.value = null;\n  selectedChapterNumber.value = 1;\n  // Verses query will become disabled automatically if selectedChapterId is null\n});\n\n// Function to change chapter\nconst changeChapter = (direction: 1 | -1) => {\n  if (!chapters.value || chapters.value.length <= 1) return;\n\n  const currentIdx = chapters.value.findIndex(ch => ch.chapter_id === selectedChapterId.value);\n  // Handle case where current chapter isn't found (shouldn't happen often with watcher)\n  if (currentIdx === -1 && chapters.value.length > 0) {\n    const newChapter = chapters.value[0];\n    console.warn(\"Current chapter ID not found, resetting to first chapter.\");\n    selectedChapterId.value = newChapter.chapter_id;\n    selectedChapterNumber.value = newChapter.chapter_number;\n    return;\n  }\n\n  const newIdx = currentIdx + direction;\n\n  if (newIdx >= 0 && newIdx < chapters.value.length) {\n    const newChapter = chapters.value[newIdx];\n    console.debug(`Changing chapter to: ${newChapter.chapter_number} (ID: ${newChapter.chapter_id})`);\n    // Update local state refs - Vue Query watcher on useVerses will trigger refetch\n    selectedChapterId.value = newChapter.chapter_id;\n    selectedChapterNumber.value = newChapter.chapter_number;\n  }\n};\n\n</script>\n\n<style scoped>\n.book-detail-view {\n  padding-top: var(--spacing-lg);\n  padding-bottom: var(--spacing-lg);\n}\n\n.book-header {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: var(--spacing-sm);\n}\n\n.book-header h1 {\n  margin-bottom: var(--spacing-xs);\n}\n\n.version-selector {\n  font-size: 0.95em;\n  color: var(--text-secondary);\n}\n\n.version-selector label {\n  margin-right: var(--spacing-xs);\n}\n\n.version-selector select {\n  padding: var(--spacing-xs) var(--spacing-sm);\n  border-radius: var(--radius-sm);\n  border: 1px solid var(--border-primary);\n  background-color: var(--bg-primary);\n  color: var(--text-primary);\n  min-width: 150px;\n}\n\n.single-version {\n  font-size: 0.95em;\n  color: var(--text-secondary);\n  margin: 0;\n}\n\n\nmain {\n  margin-top: var(--spacing-lg);\n}\n\n.chapter-nav {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: var(--spacing-sm) 0;\n  margin-bottom: var(--spacing-lg);\n  border-bottom: 1px solid var(--border-divider);\n  border-top: 1px solid var(--border-divider);\n}\n\n.chapter-nav span {\n  font-weight: 600;\n  color: var(--text-heading);\n  flex-grow: 1;\n  text-align: center;\n  margin: 0 var(--spacing-sm);\n}\n\n.chapter-nav button {\n  padding: var(--spacing-xs) var(--spacing-md);\n  border: 1px solid var(--border-primary);\n  background-color: var(--bg-secondary);\n  color: var(--text-link);\n  border-radius: var(--radius-sm);\n  cursor: pointer;\n  transition: background-color var(--transition-fast);\n}\n\n.chapter-nav button:hover:not(:disabled) {\n  background-color: var(--bg-tertiary);\n  border-color: var(--border-hover);\n}\n\n.chapter-nav button:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.single-chapter-heading {\n  text-align: center;\n  margin-bottom: var(--spacing-lg);\n  font-weight: 500;\n  font-size: 1.2rem;\n  color: var(--text-secondary);\n}\n\n.content-area {\n  margin-top: var(--spacing-lg);\n}\n\n.verses-container {\n  line-height: 1.8;\n  padding: 0 var(--spacing-sm);\n}\n\n.verse {\n  margin-bottom: var(--spacing-md);\n}\n\n.verse sup {\n  font-weight: bold;\n  margin-right: 0.6em;\n  color: var(--text-link);\n  font-size: 0.8em;\n  line-height: 1;\n  vertical-align: super;\n}\n\n.no-results {\n  text-align: center;\n  color: var(--text-secondary);\n  margin-top: var(--spacing-xl);\n  font-style: italic;\n}\n</style>",
    "GenreDetailView.vue": "//src/views/GenreDetailView.vue\n\n<template>\n  <div class=\"genre-detail-view container\">\n    <header class=\"view-header\">\n      <BaseLoadingIndicator v-if=\"isLoadingGenre\" message=\"Loading genre details...\" />\n      <BaseErrorMessage v-if=\"isErrorGenre\" :message=\"errorGenre?.message\" />\n      <h1 v-if=\"!isLoadingGenre && !isErrorGenre && genreName\">{{ genreName }}</h1>\n      <h1 v-if=\"!isLoadingGenre && !isErrorGenre && !genreName && !isLoadingGenre\">Genre Not Found</h1>\n    </header>\n\n    <main>\n      <BaseLoadingIndicator v-if=\"isLoadingBooks\" message=\"Loading books...\" />\n      <BaseErrorMessage v-if=\"isErrorBooks\" :message=\"errorBooks?.message\" />\n\n      <div v-if=\"!isLoadingBooks && !isErrorBooks && books && books.length > 0\" class=\"book-list\">\n        <router-link v-for=\"book in books\" :key=\"book.book_id\" :to=\"{\n          name: 'book-detail',\n          params: {\n            testamentSlug: props.testamentSlug,\n            genreSlug: props.genreSlug,\n            bookSlug: book.slug\n          },\n        }\" class=\"book-link list-item-link\" v-prefetch=\"createBookPrefetchOptions(book.slug)\">\n          {{ book.title }}\n        </router-link>\n      </div>\n\n      <p v-if=\"!isLoadingBooks && !isErrorBooks && books && books.length === 0\" class=\"no-results\">\n        No books found listed under this genre ({{ genreName }}).\n      </p>\n    </main>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, type Ref, watch } from 'vue';\nimport { useGenreDetails, useBooksByGenre } from '@/composables/useBibleData';\nimport { createBookPrefetchOptions } from '@/utils/prefetchHelpers';\nimport BaseLoadingIndicator from '@/components/BaseLoadingIndicator.vue';\nimport BaseErrorMessage from '@/components/BaseErrorMessage.vue';\n\ninterface Props {\n  testamentSlug: string;\n  genreSlug: string;\n}\nconst props = defineProps<Props>();\n\nconsole.log(`[GenreDetailView] Rendering with genreSlug: ${props.genreSlug}`);\n\nconst genreSlugRef = computed(() => props.genreSlug);\n\n// Fetch Genre Details\nconst {\n  data: genreDetailsData,\n  isLoading: isLoadingGenre,\n  isError: isErrorGenre,\n  error: errorGenre,\n  status: genreStatus\n} = useGenreDetails(genreSlugRef as Ref<string | undefined>);\n\n// Log genre details query results reactively\nwatch(genreStatus, (newStatus) => {\n  console.log(`[GenreDetailView] Genre Details Status: ${newStatus}`);\n  if (newStatus === 'success') {\n    console.log(`[GenreDetailView] Genre Details Data:`, genreDetailsData.value);\n  }\n  if (newStatus === 'error') {\n    console.error(`[GenreDetailView] Genre Details Error:`, errorGenre.value?.message);\n  }\n});\n\n// Recreate computed properties for genre name and ID\nconst genreName = computed(() => genreDetailsData.value?.name ?? '');\nconst genreId = computed(() => genreDetailsData.value?.genre_id ?? null);\n\n// Fetch Books based on the computed genreId ref\nconst {\n  data: books,\n  isLoading: isLoadingBooks,\n  isError: isErrorBooks,\n  error: errorBooks,\n  status: booksStatus,\n  isFetching: isFetchingBooks\n} = useBooksByGenre(genreId);\n\n// Log the enabled state for the books query directly\nconst isBooksQueryEnabled = computed(() => typeof genreId.value === 'number');\nwatch(isBooksQueryEnabled, (enabled) => {\n  console.log(`%c[GenreDetailView] Is Books Query Enabled?: ${enabled}`, 'color: red; font-weight: bold;');\n}, { immediate: true });\n</script>\n\n<style scoped>\n.genre-detail-view {\n  padding-top: var(--spacing-lg);\n  padding-bottom: var(--spacing-lg);\n}\n\nmain {\n  margin-top: var(--spacing-lg);\n}\n\n.book-list {\n  margin-top: var(--spacing-md);\n}\n\n.no-results {\n  text-align: center;\n  color: var(--text-secondary);\n  margin-top: var(--spacing-xl);\n  font-style: italic;\n}\n</style>",
    "HomeView.vue": "<template>\n  <div class=\"home-view container\">\n    <h1>Testaments de la Bible</h1>\n\n    <BaseLoadingIndicator v-if=\"isLoading\" message=\"Loading testaments...\" />\n    <BaseErrorMessage v-if=\"isError\" :message=\"error?.message\" />\n\n    <section v-if=\"!isLoading && !isError && testaments && testaments.length > 0\" class=\"testament-sections\">\n      <router-link v-for=\"testament in testaments\" :key=\"testament.testament_id\"\n        :to=\"{ name: 'testament-detail', params: { testamentSlug: testament.slug } }\" custom v-slot=\"{ navigate }\">\n        <div class=\"testament-section card\" role=\"link\" tabindex=\"0\" @click=\"navigate\" @keydown.enter=\"navigate\"\n          @keydown.space.prevent=\"navigate\" v-prefetch=\"{\n            queryKey: ['testament_detail', testament.slug],\n            queryFn: () => fetchTestamentBySlug(testament.slug),\n            staleTime: 60 * 1000\n          }\">\n          <h2>{{ testament.name }}</h2>\n        </div>\n      </router-link>\n    </section>\n\n    <p v-if=\"!isLoading && !isError && testaments && testaments.length === 0\" class=\"no-results\">\n      No testaments found in the database for the selected language.\n    </p>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { useTestaments } from '@/composables/useBibleData';\nimport { fetchTestamentBySlug } from '@/services/apiService';\nimport BaseLoadingIndicator from '@/components/BaseLoadingIndicator.vue';\nimport BaseErrorMessage from '@/components/BaseErrorMessage.vue';\n\n// useQuery returns specific properties\nconst {\n  data: testaments, // Access data via the 'data' ref\n  isLoading,       // True during initial fetch when no data is cached yet\n  isError,         // Boolean flag for error state\n  error            // The actual error object (Ref<Error | null>)\n  // isFetching,    // True during initial fetch AND background refetches (optional)\n} = useTestaments();\n\n</script>\n\n<style scoped>\n.home-view {\n  padding-top: var(--spacing-xl);\n  padding-bottom: var(--spacing-xl);\n}\n\nh1 {\n  margin-bottom: var(--spacing-xl);\n}\n\n.testament-sections {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n  gap: var(--spacing-lg);\n  margin-top: var(--spacing-lg);\n}\n\n.testament-section {\n  padding: var(--spacing-xl);\n  text-align: center;\n  cursor: pointer;\n}\n\n.testament-section:focus {\n  outline: 2px solid var(--text-link);\n  outline-offset: 2px;\n}\n\n.testament-section h2 {\n  margin: 0;\n  color: var(--text-heading);\n  font-size: 1.4rem;\n}\n\n.no-results {\n  text-align: center;\n  color: var(--text-secondary);\n  margin-top: var(--spacing-xl);\n  font-style: italic;\n}\n</style>",
    "NotFoundView.vue": "<template>\n    <div class=\"not-found-view container\">\n        <h1>404 - Page Not Found</h1>\n        <p>Sorry, the page you are looking for does not exist.</p>\n        <router-link :to=\"{ name: 'home' }\">Go to Home</router-link>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\n// No script logic needed for a simple not found page\n</script>\n\n<style scoped>\n.not-found-view {\n    text-align: center;\n    padding: var(--spacing-xl) var(--spacing-lg);\n}\n\n.not-found-view h1 {\n    color: var(--error-text);\n    margin-bottom: var(--spacing-md);\n}\n\n.not-found-view p {\n    color: var(--text-secondary);\n    margin-bottom: var(--spacing-lg);\n}\n</style>",
    "TestamentView.vue": "<template>\n  <div class=\"testament-view container\">\n    <header class=\"view-header\">\n      <BaseLoadingIndicator v-if=\"isLoading\" message=\"Loading Testament...\" />\n      <BaseErrorMessage v-if=\"isError\" :message=\"error?.message\" />\n      <h1 v-if=\"!isLoading && !isError && testamentName\">{{ testamentName }}</h1>\n      <h1 v-if=\"!isLoading && !isError && !testamentName\">Testament Not Found</h1>\n    </header>\n\n    <main>\n      <TestamentGenreList v-if=\"!isLoading && !isError && testamentId && props.testamentSlug\"\n        :testament-id=\"testamentId\" :testament-slug=\"props.testamentSlug\" />\n      <p v-if=\"!isLoading && !isError && !testamentId\" class=\"no-results\">\n        Could not load details for this testament.\n      </p>\n    </main>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { computed, type Ref } from 'vue';\n// No longer need useRoute if slug comes from props\nimport { useTestamentDetails } from '@/composables/useBibleData';\nimport TestamentGenreList from '@/components/TestamentGenreList.vue';\nimport BaseLoadingIndicator from '@/components/BaseLoadingIndicator.vue';\nimport BaseErrorMessage from '@/components/BaseErrorMessage.vue';\n\ninterface Props {\n  testamentSlug: string;\n}\nconst props = defineProps<Props>();\n\n// Use computed for reactive prop access passed to useQuery key\nconst slugRef = computed(() => props.testamentSlug);\n\n// Get Vue Query result object\nconst {\n  data: testamentDetails, // The raw data object { name, testament_id } | null\n  isLoading,\n  isError,\n  error\n} = useTestamentDetails(slugRef as Ref<string | undefined>); // Cast needed if prop isn't optional\n\n// Recreate computed properties based on the data returned by useQuery\nconst testamentName = computed(() => testamentDetails.value?.name ?? '');\nconst testamentId = computed(() => testamentDetails.value?.testament_id ?? null);\n\n</script>\n\n<style scoped>\n.testament-view {\n  padding-top: var(--spacing-lg);\n  padding-bottom: var(--spacing-lg);\n}\n\nmain {\n  margin-top: var(--spacing-lg);\n}\n\n.no-results {\n  text-align: center;\n  color: var(--text-secondary);\n  margin-top: var(--spacing-xl);\n  font-style: italic;\n}\n</style>"
  }
}